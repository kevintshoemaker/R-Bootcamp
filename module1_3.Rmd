---
title: "Module 1.3"
author: 'Basic plotting R (ggplot)'
date: "Fall 2022"
output:
  html_document:
    theme: journal
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	cache = TRUE
)
```

```{r echo=FALSE}

#  R Bootcamp #1, Module 3  -----------------------------         
#      University of Nevada, Reno   

#  Data visualization and statistics ----------------------

library(ggplot2)
library(cowplot)
library(tidyverse)

```


Visualization often plays a major role in the research process, from quality assurance, to data exploration, to the presentation of analytical results. 

The data visualization package *ggplot2* makes it very easy and straightforward to create a lot of different types of plots, from simple to complex.  In this module, we'll introduce ggplot syntax and briefly survey some of the package's plotting capabilities.

A good ggplot cheat sheet can be found here: [ggplot cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)

## Load script for module #1.3: Plotting

1. Click [here](module1_3.R) to download the script, and save the script to your working directory (R Project folder).

2. Load the script into your RStudio Project. To do this, open your RStudio Project and click on the folder icon in the toolbar at the top and load your script. 

Let's get started with plotting in R!

We'll start with the 'trees' dataset, which is built into R. It describes the girth, height, and volume of 31 felled black cherry trees.   

```{r}

# ?trees      # description of built in dataset  (uncomment to run)

dim(trees)   # Show the dimension of the trees dataframe                                              
str(trees)   # Show the structure of the trees dataframe

head(trees)   # Show the first few observations of the trees dataframe

summary(trees)  # Summary stats for each column

```


## ggplot basics

A typical workflow begins with initiating plotting with the **`ggplot()`** function and specifying the data frame you want to use to create your visualizations. We then often define the "x" argument (defining coordinates on an x axis) and (if applicable) a "y" argument (defining coordinates on a y axis). In ggplot these are known as aesthetic mappings! That is because it is a way of conveying information in the dataset graphically! Other ways of conveying information include point size, color, and symbol- all of these are also referred to as aesthetic mappings.

You can then add geometric objects to your plot, often using functions beginning with **`geom_`**, to represent your data in the form of a boxplot (**`geom_boxplot()`**), scatterplot (**`geom_point()`**), or a variety of other types of plots. The **`aes()`** function can be called within these "geoms" to specify which variables to display and how these data should be displayed (which data should be used to represent the bar height, or the x coordinate, or the point size, etc.). **`aes()`** can also be used within the initial call to **`ggplot()`**.

Here is an example of a simple **scatterplot** in ggplot:  

```{r}

# scatterplot

ggplot(trees, aes(x=Girth,y=Volume)) +
  geom_point()

```
And some more fancy and informative scatterplots

```{r}

    # try representing tree height using the color aesthetic
ggplot(trees, aes(x=Girth,y=Volume)) +
  geom_point(aes(col=Height))

   # try adding a regression line
ggplot(trees, aes(x=Girth,y=Volume)) +
  geom_point() +
  geom_smooth(method="lm")

```

### Change Plot Type
Because we're exploring different ways of plotting, it is useful to include multiple plots in the same image. 

We can do this using the `plot_grid()` function in the cowplot package (commonly used extensions to ggplot). Here we explore different ways of graphically representing the relationship between tree girth and volume.  

```{r eval=FALSE}

# Explore different "geoms" or plot types ----------------

plot1 <- ggplot(trees,aes(Girth,Volume)) +    # plot the relationship as a line
  geom_line()
plot2 <- ggplot(trees,aes(Girth,Volume)) +    # plot a smoothed "spline" fit of the relationship
  geom_smooth()
plot3 <- ggplot(trees,aes(Girth,Volume)) +    # plot scatterplot
  geom_point() 
plot4 <- ggplot(trees,aes(Girth,Volume)) +    # plot scatterplot with smoothed regression line
  geom_point() + 
  geom_smooth()
plot_grid(plot1,plot2,plot3,plot4,labels="auto")

```

### Change symbols, colors and point sizes

Point shape is specified using the `shape=` option. 

Color is specified using the `color=` option. 

Size is specified using the `size=` option.

If you want convey information in your data via the color, symbol, or point size, you include it as an aesthetic mapping- and link it to one of the columns in your data.

If you just want to color all the points the same way, or use the same symbol for everything, specify this outside of the aesthetic mapping. 

To illustrate this, let's use the built in `iris` dataset, which gives the sepal length/width and petal length/width (in cm), for 50 flowers from each of 3 iris species.

```{r}

# Explore different aesthetic mappings ---------------------

plot1 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # shape represents species
  geom_point(aes(shape=Species))
plot2 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +       # shape is same for everything!
  geom_point(shape=2)
plot3 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) 
plot4 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color is same across the board
  geom_point(col="purple")  
plot5 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # size represents species
  geom_point(aes(size=Species)) 
plot6 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # size is same across the board
  geom_point(size=2) 
plot_grid(plot1,plot2,plot3,plot4,plot5,plot6,ncol=2)

```

Here is a graphic illustrating the main plot symbols you can reference using `shape=`:

![](points.png)
Colors are a bit more intuitive, but here's a [link to a chart of R colors](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf))

### Themes

You can see that the default plot includes a gray background with white gridlines. This makes all of the elements on this plot easy to see, but as you start adjusting colors and identifying your personal preferences, you'll probably want to customize this -- ggplot has a ton of options for doing so. Here's a few examples of ggplot **themes**:

```{r}

# explore themes -----------------------------

plot1 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) +
  theme_bw()
plot2 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) +
  theme_classic()
plot3 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) +
  theme_minimal()
plot4 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) +
  theme_minimal_grid(font_size = 11)

plot_grid(plot1,plot2,plot3,plot4,labels = "AUTO")

# note: many other themes are available in ggplot, cowplot and other related packages

```

### Changing title and axis labels

We can also add titles, axis labels, and other options to make the plots look prettier.  

```{r}

# add additional plot elements: title, axis limis, axis labels ------------------

plot1 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) + 
  labs(x="Sepal Length (cm)")

plot2 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) + 
  labs(x="Sepal Length (cm)",y="Petal Length (cm)",color="Iris sp.")

plot3 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) + 
  labs(x="Sepal Length (cm)",y="Petal Length (cm)",color="Iris sp.",
       title="Fisher's Iris Data",subtitle = "practice with ggplot")

plot4 <- ggplot(iris,aes(Sepal.Length,Petal.Length)) +    # color represents species
  geom_point(aes(color=Species)) + 
  coord_cartesian(xlim=c(0,10),ylim=c(0,10)) +
  labs(x="Sepal Length (cm)",y="Petal Length (cm)",color="Iris sp.",
       title="Fisher's Iris Data",subtitle = "practice with ggplot")

plot_grid(plot1,plot2,plot3,plot4,labels = "AUTO")

```

## Bar Plots and box-whisker plots

```{r}

# bar plots and box-whisker plots -----------------------

plot1 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot
  geom_boxplot() 
  
plot2 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot +
  geom_violin() 

# bar plot
bar.heights <- iris %>% 
  group_by(Species) %>% 
  summarize(meanSL = mean(Sepal.Length))

plot3 <- ggplot(bar.heights, aes(Species,meanSL)) +
  geom_col()


plot4 <- ggplot(bar.heights, aes(Species,meanSL)) +
  geom_col(aes(fill=Species)) +
  theme_classic() +
  scale_fill_manual(values=c("gray","red","brown"))
  
plot_grid(plot1,plot2,plot3,plot4,labels = "AUTO")

```

But what if we want to have some error bars? 

```{r}

# Bar plot with error bars ------------------------

bar.heights <- iris %>% 
  group_by(Species) %>% 
  summarize(meanSL = mean(Sepal.Length),
            n = n(),
            sdSL = sd(Sepal.Length),
            se = sdSL/sqrt(n))
  
ggplot(bar.heights,aes(x=Species,y=meanSL)) + 
  geom_col(fill=gray(0.7),color="black") +
  geom_errorbar(aes(ymin=meanSL-2*sdSL,ymax=meanSL+2*sdSL),width=.2) +
  labs(y="Sepal Length")

```

And for a slightly more complex example, let's consider the built in `ToothGrowth` data set, which looks at tooth growth in guinea pigs under three different vitamin C doses and two different delivery methods (orange juice or ascorbic acid).  

```{r tooth}

# ?ToothGrowth
head(ToothGrowth)

```

```{r}

# toothgrowth plot -------------------


ToothGrowth$dose <- as.factor(ToothGrowth$dose)

sumTC <- ToothGrowth %>% 
  group_by(supp,dose) %>% 
  summarize(mean = mean(len),
            sd = sd(len))


p<- ggplot(sumTC, aes(x=dose, y=mean, fill=supp)) + 
  geom_col(color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
                 position=position_dodge(0.9)) +
  labs(title="Tooth growth", x="Dose (mg)", y = "Length") +
   theme_classic() +
   scale_fill_manual(values=c('#999999','#E69F00'))

print(p)


```


## A more complex worked example

As a more complex demo, let's use the Soils dataset from the 'carData' package, which contains soil attributes from a gilgai landscape (depressions caused by shrinking and swelling of clays during dry and wet seasons) in Australia.

First we will need to load a few more packages. Make sure to install any packages you don't already have! 

```{r}

# More complex example -----------------------------

library(ggthemes)
library(carData)
library(DAAG)
library(RColorBrewer)
library(leaflet)

```

Now load the dataset.

```{r}

# Load the example data -----------------------

soil <- carData::Soils    # load example data

#See what variables it contains...
head(soil)    # plot out the first few lines...

```
Staring simply, let's say we're interested in how pH, a continuous variable, varies with the contour position, a categorical factor:  

```{r}

# basic boxplot and violin plot

plot1 <- ggplot(soil) +
  geom_boxplot(aes(x=Contour, y=pH))

plot2 <- ggplot(soil) + 
  geom_violin(aes(x=Contour, y=pH))

plot_grid(plot1,plot2,labels = "AUTO")


```

Next let's try a simple scatterplot of two continuous variables, Calcium content and pH.

```{r}

# basic scatterplot

ggplot(soil) +
  geom_point(aes(x=pH, y=Ca))

```


Now let's say you wanted to examine how the relationship between pH and Ca varies with depth. You could go back to your scatterplot and use color to identify points from the different sampling depths. ggplot will select default colors that display well against the default gray background.

```{r}

########
# Color the points by depth

ggplot(soil) +
  geom_point(aes(x=pH, y=Ca, color=Depth))

```

We can play with how those points look if we want them to show up more boldly. Take note that arguments that affect all of the points equally, and don't relate to how *variables* are displayed, fall outside of the **`aes`** function.

```{r}

##########
# make additional alterations (outside the "aes" function)

ggplot(soil) +
  geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5)

```

Cool! Let's use the same grammar to plot relationships between pH and several soil nutrients on the same graph. Notice that the y axis label defaults to the first set of points (Ca), and we'd need to modify it. The depths in the legend also have no units! You'll see how to change things like axis labels and legend titles in a moment.

```{r}

######
# Plot several relationships on same graphics window

ggplot(soil, aes(x=pH)) +
  geom_point(aes(y=Ca), shape=21, fill="red", color="black", size=4, stroke=1.5) +
  geom_point(aes(y=Mg), shape=21, fill="blue", color="black", size=4, stroke=1.5) +
  geom_point(aes(y=Na), shape=21, fill="gray30", color="black", size=4, stroke=1.5)

```

Here's another way to plot multiple series, after reshaping with tidyr. This lets us plot our different nutrients as factor levels without typing each one with its specifications on its own line, and generates a legend that identifies the series (and also gives the default ggplot colors).

```{r}

#########
# Use 'tidyverse' tricks to simplify the syntax for ggplot to color by nutrient

soil.nut <- pivot_longer(soil, cols=c("Ca","Mg","Na"), names_to="nutrient",values_to = "value" )

ggplot(soil.nut) +
  geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)

```

What if instead of Na, we had K as our third nutrient of interest?

```{r}

######
# or if we wanted to plot different nutrients...

soil.nut2 <- pivot_longer(soil, cols=c("Ca","Mg","K"), names_to="nutrient",values_to = "value" )

ggplot(soil.nut2) +
  geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)

```

The problem here is that K occurs at natural concentrations that differ from the other nutrients by an order of magnitude, so it's difficult to examine them all on the same scale. One approach we can take is to plot them separately. While we're at it, let's also make sure that we specify the response units on the y-axis. 

#### Facets, scales, and themes

The next plot introduces: 

* **facets**, which allow you to display data on separate panels using some grouping variable 

* **scales**, which allow you to adjust how to represent the data with axes and colors

* **themes**, which allow you to adjust the entire plot aesthetic (using **`theme_X()`**) as well as individual elements of legends, text, and more (using **`theme()`**).


```{r fig.height=6, fig.width=14}

##########
# plot with facets, scales, and themes!

ggplot(soil.nut2) +
  geom_point(aes(x=pH, y=value, fill=nutrient), 
             shape=21, color="black", size=4, stroke=1.5) +
  facet_wrap(~nutrient, scales="free_y") +
  ylab("mg / 100 g soil") +
  theme_bw() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))
    
```


In this plot, we've kept the different colors for each nutrient, but suppressed the legend that is auto-generated by ggplot, because this information is now redundant with the headers of the three facets. In the **`facet_wrap`** function, we used **`scales`** to specify that the y-axis should be bounded to fit the data within each facet. There are some cases where you would probably want the axes to be the same -- e.g. if you were comparing raw values across groups, rather than the distributions or trends of the data.

We also changed the theme! ggplot has [8 built-in themes](http://r4ds.had.co.nz/images/visualization-themes.png) to choose from. There are also lots of other themes built into extension packages such as ggthemes. Here are a few examples of different themes applied to the plot we just made.

```{r fig.height=6, fig.width=14, echo=FALSE}

########
# Try different themes! 

    ## igray:

ggplot(soil.nut2) +
  geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5) +
  facet_wrap(~nutrient, scales="free_y") +
  ylab("mg / 100 g soil") +
  theme_igray() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))

```
**`theme_igray`**

```{r fig.height=6, fig.width=14, echo=FALSE}

   ## economist:

ggplot(soil.nut2) +
  geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5) +
  facet_wrap(~nutrient, scales="free_y") +
  ylab("mg / 100 g soil") +
  theme_economist() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))
```
**`theme_economist`**

```{r fig.height=6, fig.width=14, echo=FALSE}

    ## gdocs:

ggplot(soil.nut2) +
  geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5) +
  facet_wrap(~nutrient, scales="free_y") +
  ylab("mg / 100 g soil") +
  theme_gdocs() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))

```
**`theme_gdocs`**


Check out the options and play around with different themes until you find some that appeal to you and lend themselves to the type of data visualization and color scales you plan to use. 

You can also fine-tune pretty much any of the details (gridlines or no? plot borders? line weight of the borders and gridlines? axis label angles?) to your heart's content using the arguments in the **`theme()`** function.

Speaking of color...

#### Specifying colors

Sometimes sticking to the default colors in ggplot isn't the best choice. You might have factors representing ordered ranks, like in an experiment with different levels of light exposure, and want to represent these levels on a monochromatic scale. Or you might want to make a map displaying regions of positive or negative change in forest cover, using a diverging color scale. Or you don't even like the default ggplot colors, and have your own preferred color schemes. It's also important to remember that red-green colorblindness is fairly common, so if you are presenting data that must be distinguished by colors in a single plotting area, you should probably avoid this combination or combine it with changes in value (light to dark) in order for your plot to be accessible.

Going back to our earlier example showing Ca content by pH at different depths, let's say we want a color scheme where deeper depths are represented by darker values of the same color. We can do this by using another scale function.

One method is to use **`scale_fill_brewer`**, and select an already composed color palette from RColorBrewer (a package you'll need to install). You can check out all of the options available in RColorBrewer by entering **`display.brewer.all()`**, which shows the sequential palettes, then categorical palettes, than diverging palettes.

```{r fig.height=8, fig.width=6}

############
# Playing with colors in ggplot!

display.brewer.all()

```

I'm going to pick the YlOrBr (Yellow-Orange-Brown) palette, because those seem like good soil-y colors. Notice that because **`fill`** is mapped to the values of the data, inside this function is where I can change the title of the legend (and the labels for the different values, if I wanted to do that).

```{r}

#########
# Choose a new color palette from the RColorBrewer package

ggplot(soil) +
  geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5) +
  theme_bw() +
  ylab("Ca (mg/100g soil)") +
  scale_fill_brewer(palette="YlOrBr", name="Depth (cm)")

```

Another method is to use **`scale_fill_manual`**, with which you define your own palette.
To pick out your colors, you can use the [names of colors]('http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) already recognized by R, or use [hex codes](https://htmlcolorcodes.com/) for any color you want.


```{r}

#########
# Choose your own palette!

ggplot(soil) +
  geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5) +
  theme_bw() +
  ylab("Ca (mg/100g soil)") +
  scale_fill_manual(values=c("#FFF0BF","#FFC300","#BF9200","#604900"), name="Depth (cm)")

```

What if depth were a continuous variable, rather than a set of four discrete categories? We could use **`scale_fill_gradient`**, supply the hues we want (one for monochromatic, two for diverging) and R would map the soil depth values to color values along the gradient.

#### Trendlines

Next, we might want to add a trendline to each set of points. Try it for the plot we made of different nutrient concentrations as a function of pH. Arguments in the **`geom_smooth()`** function allow us to change the confidence level, the smoothing method, and other details.

```{r fig.height=6, fig.width=14}

##########
# add trendlines

ggplot(soil.nut2) +
  geom_point(aes(x=pH, y=value, fill=nutrient), 
             shape=21, color="black", size=4, stroke=1.5) +
  geom_smooth(aes(x=pH, y=value), method="lm", color="black") +
  facet_wrap(~nutrient, scales="free_y") +
  ylab("mg / 100 g soil") +
  theme_bw() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))

    
```

#### Density curves and error bars

Using **`geom_smooth`** to plot trendlines is a useful way to get more information from your scatterplots. To get an idea for how other kinds of statistical elements can be drawn onto ggplot plots, we'll look at examples using histograms and boxplots.

First, a simple histogram of 3 soil nutrients.

```{r fig.height=6, fig.width=14}

###########
# Adding density/smooth curves to plots

   ## first produce some histograms

ggplot(soil.nut) +
  geom_histogram(aes(x=value), color="black", fill="white", bins=15) +
  facet_wrap(~nutrient, scales="free") +
  xlab("mg / 100g soil") +
  theme_dark() +
  theme(axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))
```

Here is how to add a density curve to the histogram with another **`geom`**:

```{r fig.height=6, fig.width=14}

########
# Then add density curves

ggplot(soil.nut) +
  geom_histogram(aes(x=value, y=..density..), color="black", fill="white", bins=15) +
  geom_density(aes(x=value,color=nutrient), size=1.5) +
  facet_wrap(~nutrient, scales="free") +
  xlab("mg / 100g soil") +
  theme_dark() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))

```

And here's how we can compare our distributions to a normal distribution, using a **`stat`** function:

```{r fig.height=6, fig.width=14}

###########
# And now let's use a statistical function (dnorm) in ggplot to compare with a normal distribution:

ggplot(soil.nut) +
  geom_histogram(aes(x=value, y=..density..), color="black", fill="white", bins=15) +
  stat_function(fun = dnorm, color = "blue", size = 1.5,
                args=list(mean=mean(soil.nut$value), sd=sd(soil.nut$value))) +
  facet_wrap(~nutrient, scales="free") +
  xlab("mg / 100g soil") +
  theme_dark() +
  theme(legend.position="none",
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        strip.text = element_text(size=16, face="bold"))

```

Let's go back to our basic boxplot, the default plot for visualizing continuous data against categories.

First, you may have noticed that the whiskers do not have caps on them, as they do in base R. This is a matter of ~~principle~~ personal preference, but if capless whiskers look "off" to you, then you can work around it using **`stat_boxplot`**. **`stat`** functions are another group of functions for creating layers based on statistical properties of the data. Another example is **`stat_summary`**, which we use in the example below to add means to the boxplot. 

```{r}

#######
# add error bars and other stat summaries (e.g., mean) to boxplot

ggplot(soil, aes(x=Contour, y=pH)) +
  stat_boxplot(geom="errorbar", width=0.2) +  
  geom_boxplot() +
  stat_summary(fun.y=mean, geom="point", size=5, color="black")
  
```

### Beyond ggplot

ggplot contains an incredibly rich and powerful set of tools for visualizing data. But ggplot and base R are not your only options! A variety of packages exist for visualization, including:

##### ggplot extensions

Several packages have been created that build off of ggplot's syntax with additional functions. You can find a list of them [here](http://www.ggplot2-exts.org/gallery/). 

##### Technique-specific plotting libraries

Several analytical packages come with their own plotting functions that produce some very nice visualizations. There are dozens out there, but a few of them are [visreg](https://cran.r-project.org/web/packages/visreg/visreg.pdf) for regression plots, [corrplot](https://cran.r-project.org/web/packages/corrplot/index.html) (and its ggplot counterpart, [ggcorrplot](http://www.sthda.com/english/wiki/ggcorrplot-visualization-of-a-correlation-matrix-using-ggplot2)) for graphical presentation of correlation matrices, and [rpart.plot](https://cran.r-project.org/web/packages/rpart.plot/index.html) as a companion to the decision tree package rpart.

##### Interactive plots: leaflet and plotly

Increasingly, scientific journals are providing platforms for interactive graphics on their websites to accompany published articles. Interactive plots are also popular for personal, lab, and organizational websites, and they can provide another option for your own data exploration. Two of the most popular in R are [plotly](https://plot.ly/r/), which offers a huge variety of 2D and 3D plots, and [leaflet](https://rstudio.github.io/leaflet/), which is specifically for mapping.

Here's a quick and simple example of leaflet in action using the "possumsites" dataframe that accompanies the "possum" dataset in the DAAG package. The dataset contains body measurements of several possums in Australia. Where did they catch these possums?

```{r eval=FALSE}

##########
# use leaflet for interactive mapping!

leaflet(possumsites) %>%
  addTiles() %>% #Adds map tiles from OpenStreetMap
  addMarkers(lng=c(possumsites$Longitude), lat=c(possumsites$Latitude), 
             popup=c(as.character(possumsites$altitude))) #Adds markers for the sites

```

Happy plotting!






## Challenge Yourself by recreating the following plots:

Feel free to work in groups!    

### Using colors





```{r, echo=FALSE}

```

### Bar Plots Challenge

The following data represent survival of plant seedlings in 4 different treatments: ambient, watered, heated + watered, and heated. Make a bar plot with their 95% confidence intervals. Note these are asymmetric (more uncertainty above the mean than below), like what might come from a logistic regression model. Try and re-create the plot below:

```{r}

prop <- c(0.18, 0.25, 0.13, 0.05)
asympLCL <- c(0.14, 0.20, 0.11, 0.035)
asympUCL <- c(0.24, 0.33, 0.18, 0.09)

```

![](plantsurv1.png)

### Scatterplot Challenge Error Bars
The randomly generated data below are measurements of the number of the number of angels who get their wings as a function of the number of bells that have been rung. There is some uncertainty in measuring wing acquisition (represented as the offset from the sampled mean). How would you add error bars to a scatter plot? See if you can re-create the plot below: 

```{r}

set.seed(13)
n <- 20 # Number of experimental trials
a <- 12
b <- 1.5

rings <- round(runif(n)*50)  # number of bell rings
wings <- round(a + b*rings + rnorm(n, sd=5))       # number of angels who get their wings
offset <- rpois(n, lambda=10)           # measurement error
lwr <- wings - offset                 
upr <- wings + offset

```

![](ringswings1.png)

## Statistics in R!

R is a programming environment developed specifically for working with data and running statistical analyses! Let's run some basic statistics in R! 

### Load data

First, download the sculpin eggs data [here](sculpineggs.csv) and save this to your working directory.


```{r}

####################
# STATISTICS!
####################

#####
#####  Load Data
#####

sculpin.df <- read.csv("sculpineggs.csv")

head(sculpin.df)

```

### Summary statistics

Let's start by generating summary statistics, some of which are the same ones that are displayed by the "summary()" function. Most of the function names are pretty intuitive, like mean() and median():

```{r}

#####
#####  Summary Statistics
#####

mean(sculpin.df$NUMEGGS)      # compute sample mean
median(sculpin.df$NUMEGGS)    # compute sample median

min(sculpin.df$NUMEGGS)       # sample minimum
max(sculpin.df$NUMEGGS)       # sample maximum
range(sculpin.df$NUMEGGS)     # both min and max.

quantile(sculpin.df$NUMEGGS,0.5)            # compute sample median using quantile function
quantile(sculpin.df$NUMEGGS,c(0.25,0.75))   # compute sample quartiles

var(sculpin.df$NUMEGGS)           # sample variance
sd(sculpin.df$NUMEGGS)            # sample standard deviation
sd(sculpin.df$NUMEGGS)^2          # another way to compute variance
var(sculpin.df$NUMEGGS)^0.5       # another way to compute std. dev.

colMeans(sculpin.df)           # column mean of data frame
apply(sculpin.df,2,mean)       # column mean of data frame   # note the use of the "apply()" function. 
apply(sculpin.df,2,median)     # column median of data frame


########
# Or just use the "summary()" function!

summary(sculpin.df) # provides a set of summary statistics for all columns in a data frame. 


```

If your data have missing values (coded as 'NA' in R), some statistical functions won't work properly unless you specify an "na.rm=TRUE" argument (click [here](data_missing.txt) if you don't already have the test dataset with missing values):

```{r}

###########
# Deal with missing data

newdf <- read.table(file="data_missing.txt", sep="\t", header=T)  # load dataset with missing data

mean(newdf$Export)

mean(newdf$Export,na.rm = TRUE)

```


### Visual exploration

Plots (see beginning of module) take data exploration to the next level- we can start to discern patterns and identify outliers visually, giving us cues for further analyses we might want to perform. 

```{r}

#####
#####  Plot data 
#####

hist(sculpin.df$NUMEGGS)

plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)

```


### Linear Regression

The plot above suggests a fairly strong relationship between sculpin weight ("FEMWT") and number of eggs ("NUMEGGS"). Let's try to model this relationship!

Note the use of the generic "summary()" function below, which returns something very different when the input object is a linear model vs. when the input object is a data frame!

Also note the use of the "predict()" function, which not only allows you to use the model to make predictions, but also reports the uncertainty bounds on these predictions (via confidence or prediction intervals). 

```{r}

#####
#####  Linear Regression  
#####

m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)      # fit linear regression model

m1                                      # view estimates of intercept and slope 
summary(m1)                             # view summary of fit
summary(m1)$r.squared                   # extract R-squared
confint(m1)                             # confidence intervals for intercept and slope
AIC(m1)                                 # report AIC (Akaike's Information Criterion, used to perform model selection) 

plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)    # plot data
abline(m1)                                           # plot line of best fit

########
# Use the "predict()" function!

FEMWT.pred <- data.frame(FEMWT = 30)                   # create new data frame to predict number of eggs at FEMWT of 30
predict(m1,newdata=FEMWT.pred)                         # make prediction
predict(m1,newdata=FEMWT.pred,interval="confidence")   # make prediction and get confidence interval
predict(m1,newdata=FEMWT.pred,interval="prediction")   # make prediction and get prediction interval


```


### Model selection example

Sometimes we may be uncertain which model is "best". In this case, we run a set of **plausible models** and compare these models using metrics of model fit and performance, like AIC or R-squared. 

Note the use of the "I()" within the formula specification (i.e., the "[response] ~ [predictors]" statement). Using "I()" causes R to interpret what's inside the parentheses literally ("as is"), instead of using R's formula shorthands. For instance, you might try running a linear model ("lm()") in the following two ways and see how the results differ!

Click [here](http://faculty.washington.edu/jmiyamot/p448/hahnpr%20r%20formula%20notation.pdf) for more information on R's formula notation.

```{r eval=FALSE}

##########
#  Explore the use of the "I()" syntax to interpret mathematical expressions literally (as is) within formulas. 

mod_noI <- lm(NUMEGGS ~ FEMWT^2, data=sculpin.df)                  # fit linear regression model. But the "^2" doesn't seem to do anything here? What happened?
summary(mod_noI)

mod_withI <- lm(NUMEGGS ~ I(FEMWT^2), data=sculpin.df)                  # fit linear regression model
summary(mod_withI)

```

Below we perform AIC model selection and also visualize the differences between these alternative linear models.

A flexible method for visualizing the fit of alternative linear models involves overlaying predictions from each model (using the "predict()" function) on a basic scatterplot:   

```{r results=FALSE}

##################################
####  Model selection example ####
##################################

## Try to work through these examples and make sure you understand them before moving on to the challenge exercises.

m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)

m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)

m3 <- lm(NUMEGGS ~ I(FEMWT^0.5), data=sculpin.df)           # fit linear regression with intercept and sqrt of FEMWT term
summary(m3)

```


```{r}

plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model

#########
#  Here's a flexible method for drawing any arbitrary non-linear relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred)             # make prediction using "predict()" function
lines(FEMWT.pred$FEMWT,NUMEGGS.pred,col="green")  # plot sqrt model (note the use of the "lines()" function to draw a line!)

########
# Perform model selection!


#Compare models using AIC
AIC(m1)
AIC(m2)
AIC(m3)

#Compare models using R-squared
summary(m1)$r.squared 
summary(m2)$r.squared 
summary(m3)$r.squared 

#########
#  And finally, here's how you can draw a confidence interval or prediction interval around a regression relationship!

plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model


```


### Statistics challenge exercises

1: Fit a linear regression model with NUMEGGS as the response and some other transformation of FEMWT (e.g., lm(NUMEGGS ~ I(FEMWT^3))) as the predictor.

2: Plot the data and the curve of best fit from #1. How does the model fit the data?

3: Fit a linear regression model with NUMEGGS as the response and with both a linear and quadratic effect of FEMWT (within the same formula).

4: Plot the data and the curve of best fit from #1 and #3. Compare the two models. Can you identify a "best model"? If so, which one?

5: Predict the number of eggs (along with prediction interval) for FEMWT=15 using the models you fit in #1 and #3. 

How do the predictions compare?



[--go to next module--](module2_1.html)








