---
title: "Submodule 2.2"
author: "Basic programming in R"
date: "Fall 2022"
output: 
  html_document: 
    theme: journal
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, message = FALSE)
```

```{r echo=FALSE}

#  R Bootcamp #1, submodule 2.2 ---------------------------
#    University of Nevada, Reno         
#    PROGRAMMING: FUNCTIONS AND MORE         

```


## Load script for submodule #2.2

1. Click [here](module2_2.R) to download the script! Save the script to your working directory (R Project directory).

2. Load your script in your RStudio Project. To do this, open your RStudio Project and click on the folder icon in the toolbar at the top and load your script. 

Let's get started with basic programming in R!

*One quick note*: this submodule primarily uses base R instead of the tidyverse. You'll notice that we use the `plot()` function, which is R's built in plotting functionality. This is less sophisticated than ggplot in many ways, and is much harder to use for quick data visualizations, but it's still useful to know how to use ...  

## Functions in R

Everything in R can be boiled down to this: data are expressed as *vectors*, and data objects are managed, manipulated, and visualized via **functions**. Functions are absolutely central!

Let's start with a blank workspace: 

```{r}

# Start with blank workspace -------------------

rm(list=ls())

```

Base R already includes lots of functions, and thousands more functions are available in packages that you can install. Nonetheless, it's really useful to know how to write your own functions! For example, we might write our own function if we have to repeat certain sets of operations over and over in different contexts. 

We use the following syntax when we are writing our own functions:

```

my.function <- function(input1,input2,...){         # function takes various arguments (inputs)
    
    ## [Algorithm goes here: Do something useful with the inputs]
    
    return(output)  # return some output
}

```

### 'Mean' function

Let's write a function to compute the mean of a numeric vector. Okay fine, base R already has the "mean()" function, but let's do it anyway!

```{r}

## We can write our own functions. Useful if we have to repeat the same operations over and over with different inputs.
my.mean <- function(x){       # 'x' is the function argument- 'x' stands in for whatever numeric vector the user wants
    m <- sum(x)/length(x)
    return(m)
}

foo <- c(2, 4, 6, 8)
my.mean(foo)


```

Here, the variable "x" stands in for any possible numeric vector. The function takes the user input, names it "x" (within the function environment), computes a new scalar variable "m" that represents the mean of the vector "x", and returns the variable "m".

### 'Square' function

How about a function to square its arguments?

```{r}

## A function to square the arguments.
square <- function(x){
    x^2
}

## Square a single value (scalar).
square(2)

## Square all elements of a vector.
square(1:10)


```

If there is no explicit `return` function, the function will return the output of the last command (line of code) within the function.

### 'Logit' function

The logit operation (log-odds) is often used for working with probabilities. Let's write it ourselves!

```{r}

## Often, we need to write functions that are not included in the base R package e.g., the logit function.
## Calculate the log-odds (logit).
logit <- function(x){
    log(x/(1-x))
}

## Calculate logit of 0.9.
logit(.9)

## Sequence between 0 and 1.
x <- seq(from = 0, to = 1, by = 0.01)

## Caclulate the logit of a vector.
logit.x <- logit(x)
logit.x

## Plot x on x-axis, and logit(x) on y axis.
plot(x, logit.x, type = 'l',xlab="x",ylab="logit(x)")    # View the output graphically.


```


## Conditional statements 

Conditional, or logical, operations (IF [condition] THEN [do something] ELSE [do something]) are a basic building block of computer programming. 

### if...else statements in R

The basic syntax for if...else statements in R is as follows:

```

if([some condition]){               ## if some condition is met
  [execute some commands]
}else if ([some other condition]){   ## if some other condition is met (often this clause is not necessary)
  [execute some other commands]
}else{                               ## if none of the above conditions are met (otherwise...)
  [execute some other commands]
}

```

NOTE: you can include any number of nested "else if(...)" statements- or you can omit these entirely!   

Let's try it!

```{r}


#  if...else statements -----------------------

# Draw a sample from a Binomial distribution with p = 0.7 (here, p represents detection probability).
p <- 0.7            # probability of detection
x <- rbinom(n = 1, size = 1, prob = p)      # single 'coin flip' with prob success equal to p

if (x > 0) {
    print("detected")
} else {
    print("not detected")
}

```

### ifelse() function

Note that "if...else" only works for testing one condition at a time. If we have a spreadsheet with lots of data, we need something else -- something "vectorized" -- like the "ifelse()" function:

```{r}

#  ifelse()  --------------------------------

## Note if...else only works for running one logical (T/F) test at a time. If we have a spreadsheet with lots of data, we need something else.
n.samples <- 100
set.seed(2017)     # the 'seed' allows random number generators to give the same result every time!

## 100 samples from a binomial distribution with detection probability p = 0.7.
y <- rbinom(n = n.samples, size = 1, prob = p)
y

## incorrect usage
# if (y == 1) {
#     print("Detected")
# } else {
#     print("Not detected")
# }   # PRINTS A WARNING MESSAGE!

## Use ifelse instead.
detection.history <- ifelse(y == 1, print("Detected"), print("Not detected"))
detection.history

## Going the other direction.
ifelse(detection.history == "Detected", 1, 0)

xt  <-  cbind(rbinom(10, 1, .5), rbinom(10, 1, .6))
xt
ifelse(xt[, 1] > 0 & xt[, 2] > 0, print("Detected twice"),
       print("Not detected twice"))


```


## Iteration

Iterating, or running the same operation over and over sequentially, is another fundamental computer programming tool. Computers are great at performing multiple computations really, really fast! **Loops** are a good way to take advantage of computers! 

The basic syntax for iterating in R is called a "FOR loop", and looks like this:

```

for([iteration variable] in [iteration vector of length x]){
  [perform specified operation(s) x times, with the iteration variable set at each value of the iteration vector in succession]
}

```

For example... 

```{r}

#  for loops  --------------------------


for(i in 1:10){
  print(i)
}

for(j in c(1,2,3,4,5,6,7,8,9,10)){       # alternative
  print(j)
}

n.iter <- 10                   # another alternative!
count <- 0
for(i in 1:n.iter){
  count <- count+1            # assign a new value of count equal to the old value of count plus 1
  print(count)
}


```

Take the first FOR loop above. Here, "i" is the *iteration variable* and "1:n.iter" is the *iteration vector*: 

```{r}

  # closer look at iteration vector:
1:n.iter

```


Essentially, R starts this FOR loop by setting the value of the placeholder *iteration variable* "i" to the first value of the *iteration vector* (i.e., the value 1). It then runs the two commands in the body of the for loop [count <- count+1; print(count)]. Then, it sets the iteration variable "i" to the next value in the *iteration vector* (i.e., the value 2) and runs the commands again. It keeps doing this until it reaches the end of the iteration vector, at which point it stops!  

It is often useful to reference the iteration variable directly within the FOR loop. Here are some examples:

```{r}

## Using the iteration variable "i" within the for loop:
n.iter <- 5
count <- 0
for(i in 1:n.iter){
  count <- count+i            # assign a new value of count equal to the old value of count + i
  print(count)
}

## A for-loop for dependent sequence (here, the Fibonacci sequence)
n.iter <- 10
x <- rep(0, n.iter)           # set up vector of all zeros
x[1] <- 1                     # assign x_1  <-  1
x[2] <- 1                     # assign x_2 = 0
for(i in 3:n.iter){
  x[i] <- x[i-1]+x[i-2]       # x_i = x_(i-1) + x_(i-2)
}
x


```


### Iterating using the "apply() family of functions in R"

```{r}

### apply (another way to iterate) ------------------

W <- matrix(rnorm(4, 10, 3), nrow = 2, ncol = 2)  # Create a 2X2 matrix using a Normal random number generator with mu=10 and sd=3
W

## For each row, calculate the mean.
apply(W, 1, mean)

## For each column, calculate the mean.
apply(W, 2, mean)

## For each row, identify the column that has the largest value.
apply(W, 1, which.max)

## Apply your own custom function to each row in a matrix.
MyFunc <- function(x){
    2+sum(x/5)-3/2*mean(x)^2
}
apply(W, 1, MyFunc)

# lapply: apply a function across a list or vector --------------

# apply the "exp()" function to each element in the vector 1:5 

lapply(1:5,function(x) exp(x)) 


# compute the square root of volume for the first five trees in the 'trees' dataset

lapply(1:5, function(t) sqrt(trees$Volume[t]))


# sapply: same thing as 'lapply' but simplifies the returned object (i.e., into a vector if the function returns a scalar...)

mylist <- list()
mylist[[1]] <- seq(1,5,length=10)
mylist[[2]] <- c(1,.5,-.4)
mylist[[3]] <- matrix(rnorm(12,10,3),nrow=3)
sapply(mylist,function(x) sum(x)) 


```

## Challenge problems!

1. Create a custom function to calculate the predicted value $y$ for the equation $y = \beta_0 + \beta_1*x$ for any value of $\beta_0$, $\beta_1$ and $x$. Assume that $\beta_0$ and $\beta_1$ are both scalar, whereas x is a numeric vector. Use this function to calculate $y$ for the values of $x$ = 1,...,10 with $\beta_0 = 2$, and $\beta_1= -1$. Use base R plotting (`plot()` function) to plot the results.

Your result should look something like this:

```{r echo=FALSE}

regfunc <- function(beta0,beta1,x){
  beta0 + beta1*x
}

plot(1:10,regfunc(2,-1,1:10),ylab="y",xlab="x",type="p")

```


2. Write a FOR loop that takes a numeric vector as input and computes the cumulative mean (for each element of the vector, compute the mean of all previous elements of the vector, including the current element). 

If you apply this loop to the following vector "x": 

```{r}

x=c(5,4,7,3,10,2,5,4,7,6)

```

You should get the following result:

```{r echo=FALSE}

cummean <- rep(0, times=length(x))
for(i in 1:length(x)){
  cummean[i] <- mean(x[1:i])
}
cummean

```

3. Using the built-in 'volcano' dataset (a matrix of elevation data with columns representing longitude and rows representing latitude), calculate the standard deviation of elevation as an index of 'ruggedness' from the rows () of the volcano elevation data matrix. Using the "apply()" function. Which row (latitude band) of the 'volcano' dataset has the most rugged terrain?

Here's a quick look at the volcano dataset:

```{r}

filled.contour(volcano, color.palette = terrain.colors, asp = 1)
title(main = "volcano data: filled contour map")

```



```{r}


# CHALLENGE EXERCISES   -------------------------------------

#1: Create a custom function to calculate the predicted value y 
#    for the equation y = beta_0 + beta_1*x for any value of 
#    beta_0, beta_1 and x. Assume that beta_0 and 
#    beta_1 are both scalar, whereas x is a numeric vector. 
#    Use this function to calculate y for the values of 
#    $x$ = 1,...,10 with $\beta_0 = 2$, and $\beta_1= -1$. 
#    Use base R plotting (`plot()` function) to plot the results.
#
#2: Write a FOR loop that takes a numeric vector as input and 
#    computes the cumulative mean (for each element of the vector, 
#    compute the mean of all previous elements of the vector, 
#    including the current element). 
#
#3: Using the built-in 'volcano' dataset (a matrix of elevation data 
#    with columns representing longitude and rows representing latitude),
#    calculate the standard deviation of elevation as an index of
#    'ruggedness' from the rows () of the volcano elevation data matrix.
#    Using the "apply()" function. Which row (latitude band) of the
#    'volcano' dataset has the most rugged terrain?

```



```{r include=FALSE, eval=FALSE, echo=FALSE}


# Module 2_2 challenge problems: answers  -------------

#1: Create a custom function to calculate the predicted value y 
#    for the equation y = beta_0 + beta_1*x for any value of 
#    beta_0, beta_1 and x. Assume that beta_0 and 
#    beta_1 are both scalar, whereas x is a numeric vector. 
#    Use this function to calculate y for the values of 
#    $x$ = 1,...,10 with $\beta_0 = 2$, and $\beta_1= -1$. 
#    Use base R plotting (`plot()` function) to plot the results.

regfunc <- function(beta0,beta1,x){
  beta0 + beta1*x
}

plot(1:10,regfunc(2,-1,1:10),ylab="y",xlab="x",type="p")

#
#2: Write a FOR loop that takes a numeric vector as input and 
#    computes the cumulative mean (for each element of the vector, 
#    compute the mean of all previous elements of the vector, 
#    including the current element). 

x=c(5,4,7,3,10,2,5,4,7,6)
cummean <- rep(0, times=length(x))
for(i in 1:length(x)){
  cummean[i] <- mean(x[1:i])
}
cummean

#
#3: Using the built-in 'volcano' dataset (a matrix of elevation data 
#    with columns representing longitude and rows representing latitude),
#    calculate the standard deviation of elevation as an index of
#    'ruggedness' from the rows () of the volcano elevation data matrix.
#    Using the "apply()" function. Which row (latitude band) of the
#    'volcano' dataset has the most rugged terrain?

which.max(apply(volcano,1,sd))

```




[--go to next module--](module2_3.html)



