st_crs(sf_points)
## summary funciton
summary(sf_points)
## what type is the geometry column
class(sf_points$geometry)
## plot the data
plot(sf_points[0])
# subset an sf object ----
phpl <- sf_points[sf_points$species == 'Phrynosoma platyrhinos', ]
head(phpl)
## check to see that there is only one species in the data.frame
phpl %>% magrittr::extract2('species') %>% unique()
class(sf_points)
## we can filter using dplyr syntax
sf_points %>%
dplyr::filter(species == 'Phrynosoma platyrhinos') %>%
head()
## plot with sf::plot
plot(head(sf_points, n = 100))
plot(head(sf_points['year'], n = 100))
## the plot function also uses this syntax to select a single row to plot
## plot(head(sf_points['year'], n = 100))
## and if you don't want to color the plot by feature you can use 0
## to specify plotting 0 attributes
## note, this is plotting all the points
plot(sf_points[0], col = 'purple')
#############
# Nevada Counties example...
# read in nv county shapefile ----
counties <- st_read(dsn = 'data/nv_counties/NV_Admin_Counties.shp')
## once finished check the structure
str(counties, max.level = 3)
## some data management
### check the contents of the geometry field
counties$geometry
### let's double check that projection of the counties
st_crs(counties)
### How does this projection compare to the sf_points object?
### double check the sf_points projection
st_crs(sf_points)
### then explicitly compare them using boolean logic
st_crs(counties) == st_crs(sf_points)
### let's reproject the points to our desired CRS, utm
### we will go into more detail on reprojections later
counties <- st_transform(counties, st_crs(sf_points))
### double check they are equal
st_crs(counties) == st_crs(sf_points)
## check structure of a polygon within a SpatialPolygonsDataFrame
str(counties)
## check the geometry type
class(counties$geometry)
## print the first few rows for inspection
head(counties, n = 4)
## plot a spatial polygon
plot(counties)
## we don't wan't to color by any feature
## st_geometry returns just the geometry column
plot(st_geometry(counties))
## we can plot certain polygons...
## which has a plotting behavior we aren't used to
## this will plot every attribute for the first county
plot(counties[1, ])
## if we only want to include the outline, the following will work
plot(st_geometry(counties)[1])
## multiple at once
layout(matrix(1:3, ncol = 3, nrow = 1))
plot(st_geometry(counties)[1])
plot(st_geometry(counties)[1:4])
plot(st_geometry(counties)[counties$CNTYNAME == 'Clark'])
## we can even plot our reptile points ontop of the counties
layout(matrix(1))
plot(st_geometry(counties))
plot(st_geometry(sf_points), pch = 1, cex = .5, col = 'purple', add = TRUE)
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_5.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
cache = TRUE
)
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module2_1.Rmd")
?Reduce
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_5.Rmd")
rmd2rscript2("module1_1.Rmd")
?replace
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
cache = TRUE
)
# bar plots, box-whisker plots, violin plots  -----------------------
plot1 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot
geom_boxplot()
library(ggplot2)
# bar plots, box-whisker plots, violin plots  -----------------------
plot1 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot
geom_boxplot()
plot2 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot +
geom_violin()
# bar plot
bar.heights <- iris %>%
group_by(Species) %>%
summarize(meanSL = mean(Sepal.Length))
library(tidyverse)
# bar plots, box-whisker plots, violin plots  -----------------------
plot1 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot
geom_boxplot()
plot2 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot +
geom_violin()
# bar plot
bar.heights <- iris %>%
group_by(Species) %>%
summarize(meanSL = mean(Sepal.Length))
plot3 <- ggplot(bar.heights, aes(Species,meanSL)) +
geom_col()
plot4 <- ggplot(bar.heights, aes(Species,meanSL)) +
geom_col(aes(fill=Species)) +
theme_classic() +
scale_fill_manual(values=c("gray","red","brown"))
plot_grid(plot1,plot2,plot3,plot4,labels = "AUTO")
library(cowplot)
# bar plots, box-whisker plots, violin plots  -----------------------
plot1 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot
geom_boxplot()
plot2 <- ggplot(iris,aes(x=Species,y=Sepal.Length)) +    # more informative box-whisker plot +
geom_violin()
# bar plot
bar.heights <- iris %>%
group_by(Species) %>%
summarize(meanSL = mean(Sepal.Length))
plot3 <- ggplot(bar.heights, aes(Species,meanSL)) +
geom_col()
plot4 <- ggplot(bar.heights, aes(Species,meanSL)) +
geom_col(aes(fill=Species)) +
theme_classic() +
scale_fill_manual(values=c("gray","red","brown"))
plot_grid(plot1,plot2,plot3,plot4,labels = "AUTO")
bar.heights
bar.heights
# Bar plot with error bars
bar.heights <- iris %>%
group_by(Species) %>%
summarize(meanSL = mean(Sepal.Length),
n = n(),
sdSL = sd(Sepal.Length),
se = sdSL/sqrt(n))
ggplot(bar.heights,aes(x=Species,y=meanSL)) +
geom_col(fill=gray(0.7),color="black") +
geom_errorbar(aes(ymin=meanSL-2*sdSL,ymax=meanSL+2*sdSL),width=.2) +
labs(y="Sepal Length")
# ?ToothGrowth
head(ToothGrowth)
# toothgrowth plot
ToothGrowth$dose <- as.factor(ToothGrowth$dose)
sumTC <- ToothGrowth %>%
group_by(supp,dose) %>%
summarize(mean = mean(len),
sd = sd(len))
p<- ggplot(sumTC, aes(x=dose, y=mean, fill=supp)) +
geom_col(color="black",
position=position_dodge()) +
geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
position=position_dodge(0.9)) +
labs(title="Tooth growth", x="Dose (mg)", y = "Length") +
theme_classic() +
scale_fill_manual(values=c('#999999','#E69F00'))
print(p)
# toothgrowth plot
ToothGrowth$dose <- as.factor(ToothGrowth$dose)
sumTC <- ToothGrowth %>%
group_by(supp,dose) %>%
summarize(mean = mean(len),
sd = sd(len))
p<- ggplot(sumTC, aes(x=dose, y=mean, fill=supp)) +
geom_col(color="black",
position=position_dodge()) +
geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
position=position_dodge(0.1)) +
labs(title="Tooth growth", x="Dose (mg)", y = "Length") +
theme_classic() +
scale_fill_manual(values=c('#999999','#E69F00'))
print(p)
# toothgrowth plot
ToothGrowth$dose <- as.factor(ToothGrowth$dose)
sumTC <- ToothGrowth %>%
group_by(supp,dose) %>%
summarize(mean = mean(len),
sd = sd(len))
p<- ggplot(sumTC, aes(x=dose, y=mean, fill=supp)) +
geom_col(color="black",
position=position_dodge()) +
geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
position=position_dodge()) +
labs(title="Tooth growth", x="Dose (mg)", y = "Length") +
theme_classic() +
scale_fill_manual(values=c('#999999','#E69F00'))
print(p)
# toothgrowth plot
ToothGrowth$dose <- as.factor(ToothGrowth$dose)
sumTC <- ToothGrowth %>%
group_by(supp,dose) %>%
summarize(mean = mean(len),
sd = sd(len))
p<- ggplot(sumTC, aes(x=dose, y=mean, fill=supp)) +
geom_col(color="black",
position=position_dodge()) +
geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
position=position_dodge(0.9)) +
labs(title="Tooth growth", x="Dose (mg)", y = "Length") +
theme_classic() +
scale_fill_manual(values=c('#999999','#E69F00'))
print(p)
# More complex demo -----------------------------
library(ggthemes)
library(carData)
library(DAAG)
library(RColorBrewer)
# Load the example data
soil <- carData::Soils    # load example data
#See what variables it contains...
head(soil)    # plot out the first few lines...
# basic boxplot and violin plot
plot1 <- ggplot(soil) +
geom_boxplot(aes(x=Contour, y=pH))
plot2 <- ggplot(soil) +
geom_violin(aes(x=Contour, y=pH))
plot_grid(plot1,plot2,labels = "AUTO")
# basic scatterplot
ggplot(soil) +
geom_point(aes(x=pH, y=Ca))
# Color the points by depth
ggplot(soil) +
geom_point(aes(x=pH, y=Ca, color=Depth))
# make additional alterations (outside the "aes" function)
ggplot(soil) +
geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5)
# Plot several relationships on same graphics window
ggplot(soil, aes(x=pH)) +
geom_point(aes(y=Ca), shape=21, fill="red", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Mg), shape=21, fill="blue", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Na), shape=21, fill="gray30", color="black", size=4, stroke=1.5)
ggplot(soil.nut) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)
# Use 'tidyverse' to reshape the data
soil.nut <- pivot_longer(soil, cols=c("Ca","Mg","Na"), names_to="nutrient",values_to = "value" )
soil.nut
ggplot(soil.nut) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)
# or if we wanted to plot different nutrients...
soil.nut2 <- pivot_longer(soil, cols=c("Ca","Mg","K"), names_to="nutrient",values_to = "value" )
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)
# plot with facets, scales, and themes!
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient),
shape=21, color="black", size=4, stroke=1.5) +
facet_wrap(~nutrient, scales="free_y") +
labs(y="mg / 100 g soil") +
theme_bw() +
theme(legend.position="none",
axis.text = element_text(size=20),
axis.title = element_text(size=25),
strip.text = element_text(size=25, face="bold"))
# Choose a new color palette from the RColorBrewer package
ggplot(soil) +
geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5) +
theme_classic() +
labs(y="Ca (mg/100g soil)") +
scale_fill_brewer(palette="YlOrBr", name="Depth (cm)")
# Choose your own palette!
ggplot(soil) +
geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5) +
theme_bw() +
ylab("Ca (mg/100g soil)") +
scale_fill_manual(values=c("#FFF0BF","#FFC300","#BF9200","#604900"), name="Depth (cm)")
# add trendlines
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient),
shape=21, color="black", size=4, stroke=1.5) +
geom_smooth(aes(x=pH, y=value), method="lm", color="black") +
facet_wrap(~nutrient, scales="free_y") +
ylab("mg / 100 g soil") +
theme_classic() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
# Adding density/smooth curves to plots
## first produce some histograms
ggplot(soil.nut) +
geom_histogram(aes(x=value), color="black", fill="white", bins=15) +
facet_wrap(~nutrient, scales="free") +
xlab("mg / 100g soil") +
theme_classic() +
theme(axis.text = element_text(size=20),
axis.title = element_text(size=25),
strip.text = element_text(size=25, face="bold"))
# Then add density curves
ggplot(soil.nut) +
geom_histogram(aes(x=value, y=..density..), color="black", fill="white", bins=15) +
geom_density(aes(x=value,color=nutrient), size=1.5) +
facet_wrap(~nutrient, scales="free") +
xlab("mg / 100g soil") +
theme_classic() +
theme(legend.position="none",
axis.text = element_text(size=20),
axis.title = element_text(size=25),
strip.text = element_text(size=25, face="bold"))
# And now let's use a statistical function (dnorm) in ggplot to compare with a normal distribution:
ggplot(soil.nut) +
geom_histogram(aes(x=value, y=..density..), color="black", fill="white", bins=15) +
stat_function(fun = dnorm, color = "blue", size = 1.5,
args=list(mean=mean(soil.nut$value), sd=sd(soil.nut$value))) +
facet_wrap(~nutrient, scales="free") +
xlab("mg / 100g soil") +
theme_classic() +
theme(legend.position="none",
axis.text = element_text(size=20),
axis.title = element_text(size=25),
strip.text = element_text(size=25, face="bold"))
# add error bars and other stat summaries (e.g., mean) to boxplot
ggplot(soil, aes(x=Contour, y=pH)) +
stat_boxplot(geom="errorbar", width=0.2) +
stat_boxplot() +
stat_summary(fun=mean,geom="point",size=5, color="black")
