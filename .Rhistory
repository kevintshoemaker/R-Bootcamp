)   +
stat_function(
fun = dnorm,
args = with(summarized.batters, c(mean = mean(BattingAverage[Position=="P"]),
sd = sd(BattingAverage[Position=="P"]))),
col="lightred",lwd=1.1
)   +
scale_x_continuous("Batting Average") +
labs(title = "Histogram with Normal Curve")
ggplot(summarized.batters, aes(BattingAverage)) +
geom_histogram(aes(y = ..density..,group=Pitcher)) +
geom_density(aes(col=Pitcher),lwd=1.5) +
stat_function(
fun = dnorm,
args = with(summarized.batters, c(mean = mean(BattingAverage[Position!="P"]),
sd = sd(BattingAverage[Position!="P"]))),
col="lightblue",lwd=1.1
)   +
stat_function(
fun = dnorm,
args = with(summarized.batters, c(mean = mean(BattingAverage[Position=="P"]),
sd = sd(BattingAverage[Position=="P"]))),
col="pink",lwd=1.1
)   +
scale_x_continuous("Batting Average") +
labs(title = "Histogram with Normal Curve")
summarized.year = merged.all %>%
filter(yearID>1920) %>%
group_by(yearID,lgID) %>%
summarise(Total.HR=sum(HR),
Total.R=sum(R),
Total.H=sum(H),
AB=sum(AB),
BattingAverage=sum(H) / sum(AB) ) %>%
arrange(yearID, lgID)
summarized.year
# visualize trend in home runs
ggplot(summarized.year, aes(yearID, Total.HR, col=lgID)) +
geom_line()
# visualize trend in batting average
ggplot(summarized.year, aes(yearID, BattingAverage, col=lgID)) +
geom_line()
summarized.teams.year = merged.all %>%
filter(yearID>1920) %>%
group_by(yearID,teamID) %>%
summarise(League = first(lgID),
Total.HR=sum(HR),
Total.R=sum(R),
Total.H=sum(H),
AB=sum(AB),
BattingAverage=sum(H) / sum(AB) ) %>%
arrange(desc(Total.HR))
summarized.teams.year
# visualize correlation between hits and runs
ggplot(summarized.teams.year, aes(yearID, Total.HR, col=teamID)) +
geom_line(show.legend = FALSE) +
facet_wrap('League')
# visualize correlation between hits and runs
ggplot(summarized.teams.year, aes(yearID, Total.HR, col=teamID)) +
geom_point(show.legend = FALSE) +
facet_wrap('League')
# visualize correlation between home runs and year
ggplot(summarized.teams.year, aes(yearID, Total.HR, col=teamID)) +
geom_point(show.legend = FALSE) +
geom_smooth() +
facet_wrap('League')
# visualize correlation between home runs and year
ggplot(summarized.teams.year, aes(yearID, Total.HR)) +
geom_point(show.legend = FALSE) +
geom_smooth() +
facet_wrap('League')
ggplot(summarized.teams.year,aes(yearID,Total.HR))+
geom_point() +
geom_smooth(method="lm")
model1 <- lm(Total.HR~yearID,summarized.teams.year)
summary(model1)
######
# test key assumptions visually
layout(matrix(1:4,nrow=2,byrow=T))  # set up graphics window
plot(model1)  # run diagnostic plots for our regression
round
near(0.01,0)
near(0.01,0,tol=0.2)
near
#  Create R Objects ------------------------
# scalars   --------------------------------
scalar1 <- 'this is a scalar'
scalar2 <- 104
## what happens when we run this line of code? Think about the types.
scalar1 + scalar2
# VECTORS  -------------------------------
vector1 <- c(1.1, 2.1, 3.1, 4)   # the "c()" function combines smaller data objects into a larger object
vector2 <- c('a', 'b', 'c')
d1 <- 1:3             # make a vector: 1,2,3
d2 <- myvec+3         # add 3 to all elements of the vector "myvec"
d1 <- 1:3             # make a vector: 1,2,3
d2 <- d1+3         # add 3 to all elements of the vector "myvec"
d3 <- d1+d2           # elementwise addition
length(d1)            # number of elements in a vector
sum(d3)               # sum of all elements in a vector
d2[2]                 # extract the second element in the vector
# MATRICES -----------------
mymat <- cbind(d1,d2)        # create a matrix by binding vectors, with vector d1 as column 1 and d2 as column 2
mymat
class(mymat)   # confirm that the new object "mymat" is a matrix using the 'class()' function
mymat <- matrix(c(1,2,3,4,5,6),nrow=3,ncol=2)        # create matrix another way (stack columns together)
mymat
sum(mymat)
mymat[3,2]    # extract the element in the 3rd row, 2nd column
mymat[,1]     # extract first column
# LISTS --------------------------------
mylist <- list()        # create empty list
mylist[[1]] <- c(1,2,3)     # note the double brackets- this is one way to reference list elements.
mylist[[2]] <- c("foo","bar")
mylist[[3]] <- matrix(1:6,nrow=2)
mylist
# DATA FRAMES ---------------------------
mydf <- tibble(col1=c(1,2,3),col2=c("A","A","B"))        # create a ‘tibble' data frame with two columns. Each column is a vector of length 3
mydf
# Make up an entire fake data frame!
my.data <- tibble(
Obs.Id = 1:100,
Treatment = rep(c("A","B","C","D","E"),each=20),
Block = rep(1:20,times=5),
Germination = rpois(100,lambda=rep(c(1,5,4,7,1),each=20)),   # random poisson variable
AvgHeight = rnorm(100,mean=rep(c(10,30,31,25,35,7),each=20))
)
my.data
summary(my.data)    # Use the "summary()" function to summarize each column in the data frame.
mylist[[2]]
mydf[1,2]
mydf$col2
# Make up an entire fake data frame!
my.data <- tibble(
Obs.Id = 1:100,
Treatment = rep(c("A","B","C","D","E"),each=20),
Block = rep(1:20,times=5),
Germination = rpois(100,lambda=rep(c(1,5,4,7,1),each=20)),   # random poisson variable
AvgHeight = rnorm(100,mean=rep(c(10,30,31,25,35,7),each=20))
)
my.data
summary(my.data)    # Use the "summary()" function to summarize each column in the data frame.
mydf=my.data[21:30,]  # extract rows 21 to 30 and store as a new data frame
mydf
mydf$col1    # access a column of the data frame by name
mydf=my.data[21:30,]  # extract rows 21 to 30 and store as a new data frame
mydf
mydf$col1    # access a column of the data frame by name
mydf$Treatment    # access a column of the data frame by name
# DATA FRAMES ---------------------------
df1 <- tibble(col1=c(1,2,3),col2=c("A","A","B"))        # create a ‘tibble' data frame with two columns. Each column is a vector of length 3
df1
df1[1,2]     # extract the first element in the second column
df1$col2     # extract the second column by name (alternatively, df1[["col2"]])
mydf[,3:5]
as.matrix(mydf[,3:5])
mymat <- rbind(
c(1,4),
c(2,5),
c(3,6)
)
mymat
mymart2 <- as.matrix(mydf[,3:5])
mymat2 <- as.matrix(mydf[,3:5])
mylist <- list()
mylist[[1]] <- 1:3
mylist[[2]] <- matrix(1:6,nrow=3,ncol=2)
mylist[[3]] <- data.frame(x=c(1,2,3),y=c(TRUE,FALSE,TRUE),z=c("a","a","b"))
mylist[[3]][[2]][c(1,3)]
x <- rep(seq(-1,1,length=5),each=5)
y <- rep(seq(-1,1,length=5),times=5)
df_spatial <- data.frame(long=x,lat=y)
plot(x=df_spatial$long, y=df_spatial$lat, main="Regular grid",xlab="long",ylab="lat",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5),pch=20,cex=2)
abline(v=c(-1,1),h=c(-1,1),col="green",lwd=1)
x <- rep(seq(-1,1,length=5),each=5)
y <- rep(seq(-1,1,length=5),times=5)
df_spatial <- data.frame(long=x,lat=y)
plot(x=df_spatial$long, y=df_spatial$lat, main="Regular grid",xlab="long",ylab="lat",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5),pch=20,cex=2)
abline(v=c(-1,1),h=c(-1,1),col="green",lwd=1)
?read_table
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# read_table to import textfile (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.txt.df <- read_table("data.txt", header=T, sep="")
# read_table to import textfile (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.txt.df <- read_table("data.txt")
data.txt.df
read_table("data.csv")
data.csv.df
# read.table with csv file
data.csv.df <- read_table("data.csv")
data.csv.df
# read_csv to import textfile with columns separated by commas
data.df <- read_csv("data.csv")
data.df
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
head(mtcars)
# ?str: displays the internal structure of the data object
str(mtcars)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#  UNR R workshop #1, Module 2 -------------------
#  Managing data  --------------------
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will differ from yours!
####
####  Import data files into R
####
# ?read_table    # some useful functions for reading in data
# read_table to import textfile with columns separated by whitespace
data.txt.df <- read_table("data.txt")
library(ggplot)
library(tidyverse)
library(tidyverse)
library(ggplot2)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
cache = TRUE
)
library(tidyverse)
library(ggplot2)
#  UNR R workshop #1, Module 2 -------------------
#  Managing data  --------------------
library(tidyverse)
library(ggplot2)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
cache = TRUE
)
library(tidyverse)
library(ggplot2)
#  UNR R workshop #1, Module 2 -------------------
#  Managing data  --------------------
library(tidyverse)
library(ggplot2)
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will differ from yours!
####
####  Import data files into R
####
# ?read_table    # some useful functions for reading in data
# read_table to import textfile with columns separated by whitespace
data.txt.df <- read_table("data.txt")
# read_csv to import textfile with columns separated by commas
data.df <- read_csv("data.csv")
names(data.df)
# Remove redundant objects from memory
rm(data.txt.df)
# read built-in data on car road tests performed by Motor Trend
data(mtcars)
head(mtcars)    # inspect the first few lines
# ?mtcars        # learn more about this built-in data set
####
#### Check/explore data object
####
# ?str: displays the internal structure of the data object
str(mtcars)
str(data.df)
summary(data.df)
####
#### Exporting data (save to hard drive as data file)
####
# ?write.table: writes a file to the working directory
write.table(data.df[,c("Country","Product")], file="data_export.csv", sep=",", col.names=TRUE, row.names=FALSE)   # export a subset of the data we just read in.
a <- 1
b <- data.df$Product
save(a,b,file="Module1_2.RData")
rm(a,b)   # remove these objects from the environment
load("Module1_2.RData")   # load these objects back in!
# <- assignment operator
# =  alternative assignment operator
a <- 3     # assign the value "3" to the object named "a"
a = 3      # assign the value "3" to the object named "a" (alternative)
a == 3     # answer the question: "does the object "a" equal "3"?
##############
# Clear the environment
rm(list=ls())   # clear the entire environment. Confirm that your environment is now empty!
##############
# Clear the environment
rm(list=ls())   # clear the entire environment. Confirm that your environment is now empty!
data.df <- read_csv("data.csv")  # read the data back in!
# <- assignment operator
# =  alternative assignment operator
a <- 3     # assign the value "3" to the object named "a"
a = 3      # assign the value "3" to the object named "a" (alternative)
a == 3     # answer the question: "does the object "a" equal "3"?
data.df[,2]
# Wrong!
data.df[,2]=74     # sets entire second column equal to 74! OOPS!!!
data.df[,2]
# Right
data.df[,2]==74    # tests each element of column to see whether it is equal to 74
data.df <- read.csv("data.csv")  ## correct our mistake in the previous line (revert to the original data)!
# Right
data.df[,2]==74    # tests each element of column to see whether it is equal to 74
(data.df[,2]<74)|(data.df[,2]==91)   # use the logical OR operator
data.df[,2]<74)|(data.df[,2]==91   # use the logical OR operator
data.df[,2]<74|data.df[,2]==91   # use the logical OR operator
data.df[data.df[,1] %in% sub.countries,]
sub.countries<-c("Chile","Colombia","Mexico")    # create vector of character strings
data.df[data.df[,1] %in% sub.countries,]
turtles.df <- read_table(file="turtle_data.txt", header=T, stringsAsFactors = FALSE)
turtles.df <- read_table(file="turtle_data.txt")
names(turtles.df)
head(turtles.df)
turtles.df
fem.turtles.df = turtles.df %>%
filter(sex=="female")
fem.turtles.df
turtles.df %>%
group_by(sex) %>%
summarize(meanwt = mean(weight))
unique(turtles.df$sex)
turtles.df$sex[turtles.df$sex=="fem"] <- "female"
turtles.df$sex[turtles.df$sex=="fem"] <- "female"  # correct the error
unique(turtles.df$sex)  # note the two ways of representing females...
turtles.df %>%          # summarize weight by sex
group_by(sex) %>%
summarize(meanwt = mean(weight))
subset.turtles.df <- turtles.df %>%
filter(weight >= 10)
head(subset.turtles.df)
subset.turtles.df
View(turtles.df)
turtles.df[turtles.df%in%bad.tags,]
# list of tags we do not trust the data for
bad.tags <- c(13,105)
turtles.df[turtles.df%in%bad.tags,]
turtles.df[turtles.df$tag_number%in%bad.tags,]
turtles.df
turtles.df[turtles.df$tag_number%in%bad.tags,c("sex","carapace_length","head_widgth","weigth")]
turtles.df[turtles.df$tag_number%in%bad.tags,c("sex","carapace_length","head_widgth","weight")]
turtles.df[turtles.df$tag_number%in%bad.tags,c("sex","carapace_length","head_width","weight")]
turtles.df[turtles.df$tag_number%in%bad.tags,c("sex","carapace_length","head_width","weight")]  <- NA
turtles.df
turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight >= 6 ~ "adult",
is.na(weight) ~ NA,
TRUE  ~ "subadult"
))
turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ NA,
TRUE  ~ "subadult"
))
turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
#is.na(weight) ~ NA,
TRUE  ~ "subadult"
))
?case_when
turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ "unknown",
TRUE  ~ "subadult"
))
turtles.df = turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ "unknown",
TRUE  ~ "subadult"
))
turtles.df = turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ "<NA>",
TRUE  ~ "subadult"
))
turtles.df = turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ "NA",
TRUE  ~ "subadult"
))
turtles.df = turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ NA,
TRUE  ~ "subadult"
))
NA_character_
turtles.df = turtles.df %>%
mutate(size.class = case_when(
weight < 3 ~ "juvenile",
weight > 6 ~ "adult",
is.na(weight) ~ NA_character_,
TRUE  ~ "subadult"
))
turtles.df$size.class
# To sort a data frame by one vector, you can use "order()"
turtles.df[order(turtles.df$tag_number),]
# The 'order' function returns the indices of the original (unsorted) vector in the order that they would appear if properly sorted
order(turtles.df$carapace_length)
# To sort a data frame by one vector, you can use "order()"
turtles.df[order(turtles.df$tag_number),]
turtles.df %>%
arrange(carapace_length)
turtles.df %>%
arrange(desc(carapace_length))
turtles.df %>%
arrange(sex,weight)
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read_table(file="data_missing.txt")
# Missing data is read as an NA
missing.df
# Omits (removes) rows with missing data
missing.NArm.df <- na.omit(missing.df)
missing.NArm.df
# ?is.na   (Boolean test!)
is.na(missing.df)
# ?is.na   (Boolean test!)
is.na(missing.df)
library(zoo)
?na.approx
missing.df %>%
mutate(Product = na.approx(Product))
missing.df
View(missing.df)
na.approx(missing.df$Product)
missing.df$Product
na.fill(missing.df$Product,
"A")
na.fill(missing.df$Product,"A")
na.fill(missing.df$Product,"B")
missing.df %>%
mutate(Product = na.fill(Product,"A"))
View(data.df)
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read_table(file="data_missing.txt")
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read_delim(file="data_missing.txt",delim="\t")
# Omits (removes) rows with missing data
na.omit(missing.df)
# ?is.na   (Boolean test!)
is.na(missing.df)
missing.df %>%
mutate(Export = na.approx(Product))
missing.df %>%
mutate(Export = na.approx(Export))
missing.df %>%
mutate(Export = na.approx(Export),
Import = na.approx(Import))
missing.df %>%
mutate(Export = na.approx(Export),
Import = na.approx(Import))
na.approx(missing.df$Import)
missing.df %>%
mutate( #Export = na.approx(Export),
Import = na.approx(Import))
missing.df %>%
mutate(Exp = na.approx(Export),
Imp = na.approx(Import))
missing.df %>%
mutate(Export = na.fill(Export,mean(Export,na.rm=T)),
Import = na.fill(Import,mean(Import,na.rm=T)))
complete.cases(missing.df)
# Can summarize your data and tell you how many NA's per col
summary(missing.df)
dput(mtcars)
structure(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3,
24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4,
30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8,
19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8,
8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4),
disp = c(160, 160, 108, 258, 360, 225, 360, 146.7, 140.8,
167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 75.7,
71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 145,
301, 121), hp = c(110, 110, 93, 110, 175, 105, 245, 62, 95,
123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150,
150, 245, 175, 66, 91, 113, 264, 175, 335, 109), drat = c(3.9,
3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,
3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76,
3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11
), wt = c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19,
3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2,
1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 2.14,
1.513, 3.17, 2.77, 3.57, 2.78), qsec = c(16.46, 17.02, 18.61,
19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 17.6,
18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87,
17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6
), vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1), am = c(1,
1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 4, 3,
3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3,
3, 3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4,
2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1,
2, 2, 4, 6, 8, 2)), row.names = c("Mazda RX4", "Mazda RX4 Wag",
"Datsun 710", "Hornet 4 Drive", "Hornet Sportabout", "Valiant",
"Duster 360", "Merc 240D", "Merc 230", "Merc 280", "Merc 280C",
"Merc 450SE", "Merc 450SL", "Merc 450SLC", "Cadillac Fleetwood",
"Lincoln Continental", "Chrysler Imperial", "Fiat 128", "Honda Civic",
"Toyota Corolla", "Toyota Corona", "Dodge Challenger", "AMC Javelin",
"Camaro Z28", "Pontiac Firebird", "Fiat X1-9", "Porsche 914-2",
"Lotus Europa", "Ford Pantera L", "Ferrari Dino", "Maserati Bora",
"Volvo 142E"), class = "data.frame")
sessioninfo::session_info()
ggplot2::mpg
