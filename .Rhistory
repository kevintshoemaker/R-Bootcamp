# import meteorological data from Hungry Horse (HH) and Polson Kerr (PK) dams as tibble dataframe using readr
clim_data <- read_csv("MTMetStations.csv")
# display tibble - note nice formatting and variable info, entire dataset is not displayed as is case in read.csv
clim_data
# display the last few lines of the data frame
tail(clim_data)
####
####  Use Tidyr verbs to make data 'tidy'
####
# look at clim_data -- is it in tidy format? What do we need to do to get it there?
head(clim_data)
# gather column names into a new column called 'climvar_station', and all of the numeric precip and temp values into a column called 'value'. By including -Date, we indicate that we don't want to gather this column.
clim_vars_longer <- clim_data %>% pivot_longer(
cols = !Date,
names_to = "climvar_station",
values_to = "value"
)
clim_vars_longer
# separate the climvar_station column into two separate columns that identify the climate variable and the station
clim_vars_separate <- clim_vars_longer %>% separate(
col = climvar_station,
into = c("Station","climvar")
)
clim_vars_separate
# pivot_wider distributes the clim_var column into separate columns, with the data values from the 'value' column
tidy_clim_data <- clim_vars_separate %>% pivot_wider(
names_from = climvar,
values_from = value
)
tidy_clim_data
# repeat above as single pipe series without creation of intermediate datasets
tidy_clim_data <- clim_data %>%
pivot_longer(cols = !Date,
names_to = "climvar_station",
values_to = "value") %>%
separate(col = climvar_station,
into = c("Station","climvar")) %>%
pivot_wider(names_from = climvar,
values_from = value)
tidy_clim_data
tidy_clim_data
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
########
# Load packages!
## note: if you don't already have these packages you will need to install them first!
library(tidyverse)
library(ggplot2)
library(ggthemes)
library(carData)
library(DAAG)
library(RColorBrewer)
library(leaflet)
##############
# Load the example data!
data(Soils,package = "carData")    # load example data
#See what variables it contains...
soil <- data.frame(Soils)
head(soil)
########
# basic boxplot...
ggplot(soil) +
geom_boxplot(aes(x=Contour, y=pH))
###########
# basic scatterplot
ggplot(soil) +
geom_point(aes(x=pH, y=Ca))
########
# Color the points by depth
ggplot(soil) +
geom_point(aes(x=pH, y=Ca, color=Depth))
head(iris)
ggplot(iris) +
geom_point(aes(x=Sepal.Length,y=Petal.Length))
ggplot(iris) +
geom_point(aes(x=Sepal.Length,y=Petal.Length,col="Species"))
ggplot(iris) +
geom_point(aes(x=Sepal.Length,y=Petal.Length,col=Species))
######
# Plot several relationships on same graphics window
ggplot(soil, aes(x=pH)) +
geom_point(aes(y=Ca), shape=21, fill="red", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Mg), shape=21, fill="blue", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Na), shape=21, fill="gray30", color="black", size=4, stroke=1.5)
ggplot(soil, aes(x=pH)) +
geom_point(aes(y=Ca), shape=21, fill="red", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Mg), shape=21, fill="blue", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Na), shape=21, fill="gray30", color="black", size=4, stroke=1.5)
######
# Plot several relationships on same graphics window
ggplot(soil, aes(x=pH)) +
geom_point(aes(y=Ca), shape=21, fill="red", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Mg), shape=21, fill="blue", color="black", size=4, stroke=1.5) +
geom_point(aes(y=Na), shape=21, fill="gray30", color="black", size=4, stroke=1.5)
#########
# Use 'tidyverse' tricks to simplify the syntax for ggplot to color by nutrient
soil.nut <- pivot_longer(soil, cols=c("Ca","Mg","Na"), names_to="nutrient",values_to = "value" )
ggplot(soil.nut) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)
######
# or if we wanted to plot different nutrients...
soil.nut2 <- pivot_longer(soil, cols=c("Ca","Mg","K"), names_to="nutrient",values_to = "value" )
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5)
##########
# plot with facets, scales, and themes!
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient),
shape=21, color="black", size=4, stroke=1.5) +
facet_wrap(~nutrient, scales="free_y") +
ylab("mg / 100 g soil") +
theme_bw() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
########
# Try different themes!
## igray:
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5) +
facet_wrap(~nutrient, scales="free_y") +
ylab("mg / 100 g soil") +
theme_igray() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
## economist:
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5) +
facet_wrap(~nutrient, scales="free_y") +
ylab("mg / 100 g soil") +
theme_economist() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
## gdocs:
ggplot(soil.nut2) +
geom_point(aes(x=pH, y=value, fill=nutrient), shape=21, color="black", size=4, stroke=1.5) +
facet_wrap(~nutrient, scales="free_y") +
ylab("mg / 100 g soil") +
theme_gdocs() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
############
# Playing with colors in ggplot!
display.brewer.all()
#########
# Choose a new color palette from the RColorBrewer package
ggplot(soil) +
geom_point(aes(x=pH, y=Ca, fill=Depth), shape=21, color="black", size=4, stroke=1.5) +
theme_bw() +
ylab("Ca (mg/100g soil)") +
scale_fill_brewer(palette="YlOrBr", name="Depth (cm)")
###########
# Adding density/smooth curves to plots
## first produce some histograms
ggplot(soil.nut) +
geom_histogram(aes(x=value), color="black", fill="white", bins=15) +
facet_wrap(~nutrient, scales="free") +
xlab("mg / 100g soil") +
theme_dark() +
theme(axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
########
# Then add density curves
ggplot(soil.nut) +
geom_histogram(aes(x=value, y=..density..), color="black", fill="white", bins=15) +
geom_density(aes(x=value,color=nutrient), size=1.5) +
facet_wrap(~nutrient, scales="free") +
xlab("mg / 100g soil") +
theme_dark() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
###########
# And now let's use a statistical function (dnorm) in ggplot to compare with a normal distribution:
ggplot(soil.nut) +
geom_histogram(aes(x=value, y=..density..), color="black", fill="white", bins=15) +
stat_function(fun = dnorm, color = "blue", size = 1.5,
args=list(mean=mean(soil.nut$value), sd=sd(soil.nut$value))) +
facet_wrap(~nutrient, scales="free") +
xlab("mg / 100g soil") +
theme_dark() +
theme(legend.position="none",
axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
#######
# add error bars and other stat summaries (e.g., mean) to boxplot
ggplot(soil, aes(x=Contour, y=pH)) +
stat_boxplot(geom="errorbar", width=0.2) +
geom_boxplot() +
stat_summary(fun.y=mean, geom="point", size=5, color="black")
leaflet(possumsites) %>%
addTiles() %>% #Adds map tiles from OpenStreetMap
addMarkers(lng=c(possumsites$Longitude), lat=c(possumsites$Latitude),
popup=c(as.character(possumsites$altitude))) #Adds markers for the sites
#Solution
ggplot(soil) +
geom_point(aes(pH, Ca, fill=Depth), shape=21, color='black', size=4, stroke=1.5) +
geom_smooth(method='lm', aes(pH, Ca, color=Depth), se=FALSE) +
theme_bw() +
ylab('Ca (mg/100g soil)') +
scale_fill_manual(values=c('#FFF0BF','#FFC300','#BF9200','#604900'), name='Depth (cm)') +
scale_color_manual(values=c('#FFF0BF','#FFC300','#BF9200','#604900'))
ggplot(soil) +
geom_point(aes(pH, Ca, fill=Depth), shape=21, color='black', size=4, stroke=1.5) +
geom_smooth(method='lm', aes(pH, Ca, color=Depth), se=FALSE) +
theme_bw() +
ylab('Ca (mg/100g soil)') +
scale_fill_manual(values=c('#FFF0BF','#FFC300','#BF9200','#604900'), name='Depth (cm)') +
scale_color_manual(values=c('#FFF0BF','#FFC300','#BF9200','#604900'))
ggplot(soil.nut) +
geom_boxplot(aes(nutrient, value, fill=Contour)) +
stat_summary(aes(nutrient, value),
fun=mean, geom="point", shape=18, size=4, color='black')
ggplot(soil.nut) +
geom_density(aes(x=value, fill=nutrient), color="black", alpha=0.5) +
xlab("mg / 100g soil") +
theme_dark() +
theme(axis.text = element_text(size=14),
axis.title = element_text(size=16),
strip.text = element_text(size=16, face="bold"))
?"'"
mean.Date()
?mean.Date
Methods(‘mean’)
Methods(mean)
Methods(
)
methods(‘mean’)
methods("mean")
Methods("mean")
methods("mean")
?Methods
Primitive('sum')
.Primitive('sum')
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
myname <- 'Alfred'
list.files()
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
data.df[,4]
?order
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 2                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
#########################
####  Managing data  ####
#########################
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will differ from yours!
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# read.table to import textfile (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove redundant objects from memory
rm(data.txt.df)
rm(data.csv.df)
# read built-in data on car road tests performed by Motor Trend
data(mtcars)
str(mtcars)    # examine the structure of this data object
# ?mtcars        # learn more about this built-in data set
####
#### Check/explore data object
####
# ?str: displays the internal structure of the data object
str(data.df)
# ?head: displays first n elements of object (default=6)
head(data.df)
head(data.df,2)
# ?tail: displays last n elements of object (default=6)
tail(data.df)
summary(data.df)
####
#### Exporting data (save to hard drive as data file)
####
# ?write.table: writes a file to the working directory
write.table(data.df[,c("Country","Product")], file="data_export.csv", sep=",", col.names=TRUE, row.names=FALSE)   # export a subset of the data we just read in.
####
####  Saving and loading
####
# ?save: saves particular objects to hard disk
a <- 1
b <- data.df$Product
save(a,b,file="Module1_2.RData")
rm(a,b)   # remove these objects from the environment
load("Module1_2.RData")   # load these objects back in!
##############
# Clear the environment (and load it back in!)
save.image(file="Module2.RData")    # ?save.image: saves entire environment (we don't necessarily want to clear everything right now)
rm(list=ls())   # clear the entire environment. Confirm that your environment is now empty!
load(file="Module2.RData")   # load the objects back!
# <- assignment operator
# =  alternative assignment operator
a <- 3     # assign the value "3" to the object named "a"
a = 3      # assign the value "3" to the object named "a"
a == 3     # answer the question: "does the object "a" equal "3"?
####
####  Subsetting data
####
##########
# The "which()" function -- return indices of a vector that meet a certain condition (condition is TRUE)
which(data.df[,2]==74)       # elements of column 2 that are equal to 74
which(data.df[,2]!=74)       # elements of column 2 that are NOT equal to 74
which(data.df[,2]<74)        #  and so on...
which((data.df[,2]<74)|(data.df[,2]==91))   # use the logical OR operator
#########
# Alternatively, save the indices as an R object as an intermediate step
indices <- which(data.df[,2]<74)
data.df[indices,2]               # same as above!
#########
# Alternatively, you can omit the "which()" function entirely-
#     R will know that you're trying to omit "FALSE" elements and keep "TRUE" elements
data.df[data.df[,2]<74,2]    # alternative simpler syntax without using "which()"...
sub.countries<-c("Chile","Colombia","Mexico")    # create vector of character strings
which(data.df$Country=="Chile")
# This command doesn't work because sub.countries is a vector, not a single character string.
which (data.df[,1]==sub.countries)
# Instead we use %in%
which(data.df[,1] %in% sub.countries)     # elements of data column that match one or more of the elements in "sub.countries"
which((data.df$Country %in% sub.countries) & (data.df$Product=="N"))   # use AND operator
# What if we don't want the row number, but the actual row(s) of data that meet a particular condition?
indices <- which(data.df$Country %in% sub.countries)
data.df[indices,]          # print all data for a subset of observations
####
####  Practice subsetting a data frame
####
turtles.df <- read.table(file="turtle_data.txt", header=T, stringsAsFactors = FALSE)
names(turtles.df)
head(turtles.df)
# Subset for females
fem.turtles.df <- turtles.df[which(turtles.df$sex =="female"),]
# Can subset just one factor based on another
# Here we want to know the mean weight of all females
mean(fem.turtles.df$weight)
mean(turtles.df$weight[which(turtles.df$sex =="female")])
# Try using the "subset()" function, which can make subsetting a data frame even easier!
female.turtles <- subset(turtles.df,sex=="female")              # use the "subset()" function!
female.turtles <- turtles.df[which(turtles.df$sex=="female"),]    # alternative
subset.turtles.df <- subset(turtles.df, weight >= 10)
head(subset.turtles.df)
# Subsetting to certain individuals
bad.tags <- c(13,105)
good.turtles.df <- turtles.df[!(turtles.df$tag_number %in% bad.tags),]
bad.turtles.df <- turtles.df[turtles.df$tag_number %in% bad.tags,]
bad.turtles.df
####
####  Data Manipulation using subsetting
####
# Using subset to correct data entry problems
unique(turtles.df$sex)
table(turtles.df$sex)   # do you notice the data entry problem here?
turtles.df[which(turtles.df$sex=="fem"),2]<-"female"            # recode the sex variable
# make a new variable "size.class" based on the "weight" variable
turtles.df$size.class <- NA
turtles.df$size.class[turtles.df$weight >= 6] <- 1         # ths is the "adult" class
turtles.df$size.class[turtles.df$weight < 6] <- 2          # this is the "juvenile" class
turtles.df$size.class
####
####  Sorting
####
# Sort works for ordering along one vector
sort(turtles.df$carapace_length)
# Order returns the indices of the original (unsorted) vector in the order that they would appear if properly sorted
order(turtles.df$carapace_length)
# To sort a data frame by one vector, use "order()"
turtles.tag <- turtles.df[order(turtles.df$tag_number),]
# Order in reverse
turtles.tag.rev <- turtles.df[order(turtles.df$tag_number,decreasing = TRUE),]
# Sorting by 2 columns
turtles.sex.weight <- turtles.df[order(turtles.df$sex,turtles.df$weight),]
turtles.tag.rev
####
####  Sorting
####
# Sort works for ordering along one vector
sort(turtles.df$carapace_length)
# Order returns the indices of the original (unsorted) vector in the order that they would appear if properly sorted
order(turtles.df$carapace_length)
# To sort a data frame by one vector, use "order()"
turtles.tag <- turtles.df[order(turtles.df$tag_number),]
# Order in reverse
turtles.tag.rev <- turtles.df[order(turtles.df$tag_number,decreasing = TRUE),]
# Sorting by 2 columns
turtles.sex.weight <- turtles.df[order(turtles.df$sex,turtles.df$weight),]
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read.table(file="data_missing.txt", sep="\t", header=T)
# Missing data is read as an NA
missing.df
# Omits (removes) rows with missing data
missing.NArm.df <- na.omit(missing.df)
missing.NArm.df
# ?is.na
is.na(missing.df)
# Get index of NAs
which(is.na(missing.df))
# Replace all missing values in the data frame with a 0
missing.df[is.na(missing.df)] <- 0
# Create another data frame with missing values
missing.mean.df<- read.table(file="data_missing.txt", sep="\t", header=T)
# Replace only the missing values of just one column with the mean for that column
missing.mean.df$Export[is.na(missing.mean.df$Export)] <- mean(missing.mean.df$Export,na.rm=T)
missing.mean.df
# Return only those rows with missing data
missing.df<- read.table(file="data_missing.txt", sep="\t", header=T)
missing.df <- missing.df[!complete.cases(missing.df),]
# Can summarize your data and tell you how many NA's per col
summary(missing.mean.df)
# Summarize one individual col
summary(missing.mean.df$Export)
df <- data.frame(    # build a data frame
a=1:10,
b=rnorm(10)
)
df$a       # pull out columns of the data frame
df$b
attach(df)   # "attach" the data frame  # attach make objects within dataframes accessible with fewer letters
a          # now we can reference the columns without referencing the data frame
b
detach(df)   # remember to detach when you're done
attach(df)
Import
Import<-rep(1,10) # What if we forget the names in our data frames and use that name for something else
Import
rm(Import) # But if we remove that object...
Import  # There is still the original object behind it. That's troubling!
attach(df)
df
data.df
data.df
attach(data.df)
Import
Import<-rep(1,10) # What if we forget the names in our data frames and use that name for something else
Import
rm(Import) # But if we remove that object...
Import  # There is still the original object behind it. That's troubling!
detach(data.df)   # Remember to detach
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_4.Rmd")
