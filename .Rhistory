which(is.na(missing.df))
# Replace all missing values in the data frame with a 0
missing.df[is.na(missing.df)] <- 0
# Create another data frame with missing values
missing.mean.df<- read.table(file="data_missing.txt", sep="\t", header=T)
# Replace only the missing values of just one column with the mean for that column
missing.mean.df$Export[is.na(missing.mean.df$Export)] <- mean(missing.mean.df$Export,na.rm=T)
missing.mean.df
# Return only those rows with missing data
missing.df<- read.table(file="data_missing.txt", sep="\t", header=T)
missing.df <- missing.df[!complete.cases(missing.df),]
# Can summarize your data and tell you how many NA's per col
summary(missing.mean.df)
# Summarize one individual col
summary(missing.mean.df$Export)
# Summarize one individual col
summary(missing.mean.df$Export)
# Can summarize your data and tell you how many NA's per col
summary(missing.mean.df)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_2.Rmd")
unlink("module1_2_cache", recursive = TRUE)
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_2.Rmd",rmarkdown::pdf_document())
layout(matrix(1:6,nrow=T,byrow=T))
layout.show()
layout.show(1:6)
?layout.show
layout.show(6)
layout.show(5)
layout.show(4)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
plot(x=trees$Girth, y=trees$Volume)             # points
# Use "layout" to define a 2 row x 2 column matrix with elements 1, 2, 3, and 4.
# This divides the image into four sections and then fills these with the plot function
layout(matrix(1:4, nrow=2, ncol=2))
# layout.show(4)   # uncomment to run
# par(mfrow=c(2,2))  # (alternative way to do this)
plot(x=trees$Girth, y=trees$Volume)             # points
plot(x=trees$Girth, y=trees$Volume, type="l")   # lines
plot(x=trees$Girth, y=trees$Volume, type="b")   # both
plot(x=trees$Girth, y=trees$Volume, type="o")   # both with conected lines
# Use layout to define a 2 row x 2 column matrix with elements 1, 1, 2, and 3.
# This divides the image into four sections but fills the first two sections
# with the first plot and then fills these next two sections with the final two plots
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
layout.show(3)
layout.show(1)
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
layout.show(3)
rmarkdown::render("module1_3.Rmd",rmarkdown::pdf_document())
rmd2rscript2("module1_3.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 3                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short-course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
# Thanks to John Tipton at CSU for developing much of this module (plotting in R)!
############################################
####  Data visualization and statistics ####
############################################
# ?trees      # description of built in dataset  (uncomment to run)
dim(trees)   # Show the dimension of the trees dataframe
str(trees)   # Show the structure of the trees dataframe
head(trees)   # Show the first few observations of the trees dataframe
plot(x=trees$Girth, y=trees$Volume)    # use R's built-in "trees" dataset: ?trees
# Use "layout" to define a 2 row x 2 column matrix with elements 1, 2, 3, and 4.
# This divides the image into four sections and then fills these with the plot function
layout(matrix(1:4, nrow=2, ncol=2))
# layout.show(4)   # uncomment to run
# par(mfrow=c(2,2))  # (alternative way to do this)
plot(x=trees$Girth, y=trees$Volume)             # points
plot(x=trees$Girth, y=trees$Volume, type="l")   # lines
plot(x=trees$Girth, y=trees$Volume, type="b")   # both
plot(x=trees$Girth, y=trees$Volume, type="o")   # both with conected lines
# Use layout to define a 3 row x 1 column matrix with elements 1, 2, and 3.
# This divides the image into three sections and then fills these with the plot function
layout(matrix(1:3, nrow=3, ncol=1))
# pch: 'plotting character' changes the type of point that is used (default is an open circle)!
plot(x=trees$Girth, y=trees$Volume, pch=19)     # filled point
plot(x=trees$Girth, y=trees$Volume, pch=2)      # open triangle
plot(x=trees$Girth, y=trees$Volume, pch=11)     # star
layout(matrix(1:4, 2, 2))
# main: adds a title
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees")
# xlab: adds an x axis label
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)")
# ylab: adds a y axis label
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)")
# las: rotates axis labels; las=1 makes them all parallel to reading direction
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1)
# Use layout to define a 2 row x 2 column matrix with elements 1, 1, 2, and 3.
# This divides the image into four sections but fills the first two sections
# with the first plot and then fills these next two sections with the final two plots
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
# col: select a color for the plotting characters
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col="blue")
# We can use the c() function to make a vector and have several colors, plotting characters, etc. per plot.
# We start with alternating colors for each point
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col=c("black", "blue"))
# And we can also alternate the plotting symbol at each point.
plot(x=trees$Girth, y=trees$Volume, pch=c(1,19),
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col="blue")
?iris
head(iris)     # display first few rows of data
dim(iris)      # dimensionality of the data
str(iris)      # details of the data structure
plot.colors <- c("violet", "purple", "blue")   # define the colors for representing species ID
color.vector <- rep(x=plot.colors, each=50)
color.vector
## color vector is now a list of our colors, each repeated 50 times
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Plot of Iris colored by species")
names(plot.colors) <- levels(iris$Species)   # the "levels()" function returns all unique labels for any "factor" variable
plot.colors
indices <- match(iris$Species,names(plot.colors))   # the "match()" function goes through each element of the first vector and finds the matching index in the second vector
indices
# make a new version of the iris data frame that is neither in order nor has the same number of observations for each species (to illustrate generality of the new method)
iris2 <- iris[sample(1:nrow(iris),replace = T),]   # use the "sample()" function to create a randomized ("bootstrapped") version of the iris data frame
# now repeat the above steps:
indices <- match(iris2$Species,names(plot.colors))   # the "match()" function returns the indices of the first vector that match the second vector
color.vector2 <- plot.colors[indices]
plot(x=iris2$Petal.Length, y=iris2$Sepal.Length, pch=19, col=color.vector2,
main="Iris sepal length vs. petal length", xlab="Petal length",
ylab="Sepal length", las=1)
## The old method is NOT general:
color.vector <- rep(x=plot.colors, each=50)
plot(x=iris2$Petal.Length, y=iris2$Sepal.Length, pch=19, col=color.vector,
main="Plot of Iris colored by species (not!)")
## Plot fuel economy by weight
plot(mpg~wt,  data=mtcars,pch=20,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)")      # note the tilde, which can be read "as a function of" -- i.e., "plot mpg as a function of wt"
## Plot fuel economy by weight and horsepower
hp_rescale <- with(mtcars,(hp-min(hp))/diff(range(hp)))    # scale from 0 to 1
plot(mpg~wt,  data=mtcars,pch=1,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)",cex=(hp_rescale+0.6)*1.2)   # plot with different sized points
legend("topright",pch=c(1,1),pt.cex=c(0.6,0.6*1.2),legend=paste(range(mtcars$hp),"horsepower"),bty="n")
## Plot fuel economy by weight and horsepower
hp_rescale <- with(mtcars,(hp-min(hp))/diff(range(hp)))    # scale from 0 to 1
plot(mpg~wt,  data=mtcars,pch=1,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)",cex=(hp_rescale+0.6)*1.2)   # plot with different sized points
legend("topright",pch=c(1,1),pt.cex=c(0.6,0.6*1.2),legend=paste(range(mtcars$hp),"horsepower"),bty="n")
## Plot fuel economy by weight and horsepower again- this time by color
colramp <- terrain.colors(125)
colindex <- round(hp_rescale*99+1)
plot(mpg~wt,  data=mtcars,pch=20,cex=2,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)",col=colramp[colindex])   # plot with different sized points
legend("topright",pch=c(20,20),pt.cex=c(2,2),col=c(colramp[1],colramp[100]),legend=paste(range(mtcars$hp),"horsepower"),bty="n")
by(iris$Sepal.Length, iris$Species, sd)
bar.heights - CI
CI <- 2 * tapply(iris$Sepal.Length, iris$Species, sd)
CI
lwr <- bar.heights - CI
upr <- bar.heights + CI
CI <- 2 * tapply(iris$Sepal.Length, iris$Species, sd)
lwr <- bar.heights - CI
upr <- bar.heights + CI
# I used the ylim= argument to pass a 2-element numeric vector specifying the y extent of the barplot (y axis lower and upper bounds). I added some extra room on the top to account for error bars.
# Importantly, assign the barplot to an object. I called it 'b' but you can call it whatever you like. (otherwise, it's hard to know what the "X" values of the error bars are!)
b <- barplot(bar.heights,
names.arg=c("I. setosa", "I. versicolor", "I. virginica"),
las=1, ylim=c(0,8), col=adjustcolor(plot.colors, alpha.f=0.5),
main="Sepal length for 3 Irises", ylab="Sepal length (cm)")
# Specify where each arrow starts (x0= and y0=) and ends (x1= and y1=)
arrows(x0=b, x1=b, y0=lwr, y1=upr, code=3, angle=90, length=0.1)
# ?arrows
layout(matrix(1:2, 1, 2))
## y-axis is in counts by default (total observations in each "bin")
hist(iris$Sepal.Length, main="Histogram of Sepal Length",
xlab = "Sepal Length")
## change y-axis to proportions of the entire dataset using freq=FALSE
hist(iris$Sepal.Length, freq=FALSE, main="Histogram of Sepal Length",
xlab = "Sepal Length")
## Add a density estimator
lines(density(iris$Sepal.Length))   # add a line to the histogram to approximate the probability density of the data distribution
curve(dnorm(x,mean(iris$Sepal.Length),sd(iris$Sepal.Length)),add=T,col="red",lty=3)   # add a normal distribution
plot.colors <- c("red", "blue")
# subset the colors in plot.colors based on the variable iris$Species
# iris$Species is a factor variable that has 3 levels
color.vector <- plot.colors[ToothGrowth$supp]
plot(x=ToothGrowth$dose, y=ToothGrowth$len, pch=19, col=color.vector,
main="Tooth Growth vs. Vitamin C Dose", xlab="Viatmin C Dose (mg)",
ylab="Tooth Growth (mm)", las=1)
# First legend
legend("topleft", pch=19, col=plot.colors, legend=unique(ToothGrowth$supp))
prop <- c(0.18, 0.25, 0.13, 0.05)
asympLCL <- c(0.14, 0.20, 0.11, 0.035)
asympUCL <- c(0.24, 0.33, 0.18, 0.09)
set.seed(13)
n <- 20 # Number of experimental trials
a <- 12
b <- 1.5
rings <- round(runif(n)*50)  # number of bell rings
wings <- round(a + b*rings + rnorm(n, sd=5))       # number of angels who get their wings
offset <- rpois(n, lambda=10)           # measurement error
lwr <- wings - offset
upr <- wings + offset
rmd2rscript2("module1_3.Rmd")
unlink("module1_4_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
## Sequence between 0 and 1.
x <- seq(from = 0, to = 1, by = 0.01)
logit.x <- logit(x)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 4                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
##################################################
####  PROGRAMMING: FUNCTIONS AND MORE         ####
####      author: Perry Williams              ####
##################################################
## NOTE: this module borrows heavily from an R short-course developed by a team at Colorado State University.
#######
# Start with blank workspace
rm(list=ls())
####
####  Functions
####
my.function = function(){       # this function has no arguments
message <- "Hello, world!"
return(message)
}
my.function()
my.function      # try running without parentheses-   what happens?
## We can write our own functions. Useful if we have to repeat the same operations over and over with different inputs.
my.mean <- function(x){
m <- sum(x)/length(x)
return(m)
}
foo <- c(2, 4, 6, 8)
my.mean(foo)
## A function to square the arguments.
square <- function(x){
x^2
}
## Square a single value (scalar).
square(2)
## Square all elements of a vector.
square(1:10)
## Often, we need to write functions that are not included in the base R package e.g., the logit function.
## Calculate the log-odds (logit).
logit <- function(x){
log(x/(1-x))
}
## Calculate logit of 0.9.
logit(.9)
## Sequence between 0 and 1.
x <- seq(from = 0, to = 1, by = 0.01)
## Caclulate the logit of a vector.
logit.x <- logit(x)
logit.x
## Plot x on x-axis, and logit(x) on y axis.
plot(x, logit.x, type = 'l',xlab="x",ylab="logit(x)")    # View the output graphically.
## Sequence between 0 and 1.
x <- seq(from = 0, to = 1, by = 0.01)
logit.x <- logit(x)
## The expit (or inverse logit) funtion.
expit <- function(x){
exp(x)/(1+exp(x))
}
## Calculate the inverse-logit of logit(0.9) = 2.197225.
expit(2.197225)
expit.logit.x <- expit(logit.x)    # Return to original x values.
## Plot x on x-axis, and expit(logit(x)) = x on y axis.
plot(x, expit.logit.x, type = 'l',xlab="x",ylab="expit(logit(x))")
## Plot "logistic" curve
plot(x=seq(-3,3,0.1),y=expit(seq(-3,3,0.1)),type="l",xlab="x",ylab="expit(x)")
####
####  if...else statements
####
########
# Draw a sample from a Binomial distribution with p = 0.7 (here, p is detection probability).
p <- 0.7            # probability of detection
x <- rbinom(n = 1, size = 1, prob = p)      # single 'coin flip' with prob success equal to p
if (x > 0) {
print("Detected")
} else {
print("Not detected")
}
######
# Make a "safe" version of the "logit" function
logit.safe <- function(x){
bad <- ((x<0)|(x>1))
if(any(bad)){
stop("logit is only defined for x between 0 and 1!")
}else{
log(x/(1-x))
}
}
x <- seq(from = -1, to = 2, by = 0.1)
# logit(x)      # this returns impossible numbers (NaNs)
# logit.safe(x)   # this will throw an informative error!
logit.safe(c(0.15,0.99))
## Using the iteration variable "i" within the for loop:
count <- 0
for(i in 1:n.iter){
count <- count+i            # assign a new value of count equal to the old value of count + i
print(count)
}
## Using the iteration variable "i" within the for loop:
n.iter <- 5
count <- 0
for(i in 1:n.iter){
count <- count+i            # assign a new value of count equal to the old value of count + i
print(count)
}
## A for-loop for dependent sequence (here, the Fibonacci sequence)
n.iter <- 10
x <- rep(0, n.iter)           # set up vector of all zeros
x[1] <- 1                     # assign x_1  <-  1
x[2] <- 1                     # assign x_2 = 0
for(i in 3:n.iter){
x[i] <- x[i-1]+x[i-2]       # x_i = x_(i-1) + x_(i-2)
}
x
lapply(1:5,function(x) exp(x))
lapply(1:5, function(t) sqrt(trees$Volume[t]))
mylist <- list()
mylist <- list()
mylist[[1]] <- seq(1,6,length=10)
mylist[[2]] <- c(1,5,4)
mylist[[3]] <- matrix(rnorm(12),nrow=3)
mylist
mylist <- list()
mylist[[1]] <- seq(-1,1,length=10)
mylist[[2]] <- c(1,.5,-.4)
mylist[[3]] <- matrix(rnorm(12),nrow=3)
sapply(1:5,function(x) sum(exp(x)))
sapply(mylist,function(x) sum(exp(x)))
## Simulate data.
observations <- matrix(sample(c("Detected", "NotDetected", 1, 0), 20*3, replace = TRUE), 20, 3)    # simulate detection/non-detection data over three sampling occasions
habitat <- rnorm(20, 0, 2)    # simulate environmental covariate
Data <- cbind(observations, habitat)       # bind into single matrix.
Data
matrix(c(1,1),nrow=1)
Z <- 2 * volcano        # Exaggerate the relief (multiply the elevation by 2)
Z
X <- 10 * (1:nrow(Z))   # set horizontal coordinates -- 10 meter spacing (S to N)
Y <- 10 * (1:ncol(Z))   # set vertical coordinates -- 10 meter spacing (E to W)
par(bg = "white")
layout(matrix(c(1,1),nrow=1))
persp(X,  Y, Z, theta = 135, phi = 30, col = "green3",    # "persp()" produces a 3D "perspective plot"
scale = FALSE, ltheta = -120, shade = 0.75,
border = NA, box = FALSE)
layout(matrix(c(1,1),nrow=1))
persp(X,  Y, Z, theta = 135, phi = 30, col = "green3",    # "persp()" produces a 3D "perspective plot"
scale = FALSE, ltheta = -120, shade = 0.75,
border = NA, box = FALSE)
layout(1)
persp(X,  Y, Z, theta = 135, phi = 30, col = "green3",    # "persp()" produces a 3D "perspective plot"
scale = FALSE, ltheta = -120, shade = 0.75,
border = NA, box = FALSE)
## Use a for-loop to help view many angles.
for(i in 1:18){
persp(X, Y, Z, theta = i*20, phi = 30, col = "green3",
scale = FALSE,  ltheta = -120, shade = 0.75,
border = NA, box = FALSE)
print(i*20)
readline()                               # Pauses the for-loop until [enter] is pushed
}
18*20
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_4.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(modeest)    # load the package: This is package 'modeest' written by P. PONCET.
?mlv
#########
# 3D Plotting example
#########
#########
# Data: dog barks per day (and two explanatory variables)
Cars= c(32, 28, 9, 41, 23, 26, 26, 31, 12, 25, 32, 13, 19, 19, 38,
36, 43, 26, 21, 15, 17, 12, 7, 41, 38, 33, 31, 9, 40, 21)
Food= c(0.328, 0.213, 0.344, 0.339, 0.440, 0.335, 0.167, 0.440, 0.328,
0.100, 0.381, 0.175, 0.238, 0.360, 0.146, 0.430, 0.446, 0.345,
0.199, 0.301, 0.417, 0.409, 0.142, 0.301, 0.305, 0.230, 0.118,
0.272, 0.098, 0.415)
Bark=c(15, 14, 6, 12, 8, 1, 9, 8, 1, 12, 14, 9, 8, 1, 19, 8, 13, 9,
15, 11, 8, 7, 8, 16, 15, 10, 15, 4, 17, 0)
car::scatter3d(Bark~Food+Cars,surface=TRUE)
install.packages("rgl")
car::scatter3d(Bark~Food+Cars,surface=TRUE)
library(help="car")
library(help = "car")    # help file for the useful "car" package for applied regression
browseVignettes('car')
vignette('embedding','car')   # pull up the "embedding" vignette in the 'car' package
browseVignettes('car')
library(help = "car")    # help file for the useful "car" package for applied regression
help.start()
help.start()
rmd2rscript2("module2_1.Rmd")
