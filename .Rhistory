2
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 1                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University.
# Thanks to Perry Williams at UNR for allowing us to use these materials!!
##################################################
####  Getting started with R: the basics      ####
##################################################
Batmans_butler <- 'Alfred Pennyworth'
###############
# R DEMO:
###############
#  don't worry if you don't understand this just yet- this is just a taste of where we are going!
#########
# load a built-in dataset
data(trees)
#########
# explore the data object
summary(trees)    # summary statistics for all variables in data frame
str(trees)        # summary of the data structure
#########
# visualize the data
# histograms:
layout(matrix(1:3,nrow=1,byrow = T))    # set up a multi-panel graphics device (three plots side by side)
hist(trees$Height)                       # visualize the distribution of height data
hist(trees$Girth)                        # visualize the distribution of girth data
hist(trees$Volume)                       # visualize the distribution of volume data
# bivariate scatterplots:
layout(matrix(1:2,nrow=1,byrow = T))      # set graphics device with 2 plots side by side
plot(trees$Volume~trees$Girth)            # scatterplot of volume against girth
plot(trees$Volume~trees$Height)           # scatterplot of volume against height
pairs(trees)    # plots all scatterplots together as a scatterplot matrix!
##########
# perform linear regression analysis
model1 <- lm(Volume~Girth,data=trees)        # regress Volume on Girth
summary(model1)    # examine the results
######
# test key assumptions visually
layout(matrix(1:4,nrow=2,byrow=T))
plot(model1)
#########
# visualize the results!
xvals <- seq(5,30,0.5)            # set the range of "Girth" values over which you want to make predictions about "Volume"
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)   # use the linear model to make predictions about "Volume"
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))         # Make a pretty scatterplot
abline(model1,lwd=2,col="brown")              # Add the regression line
lines(xvals,pred[,"upr"],col="brown",lty=2)       # Add the upper bound of the confidence interval
lines(xvals,pred[,"lwr"],col="brown",lty=2)       #      ... and the lower bound
text(10,80,sprintf("Volume = %s + %s*Girth",round(coefficients(model1)[1],1),round(coefficients(model1)[2],1)))       # Add the regression coefficients
text(10,65,sprintf("p = %s",round(summary(model1)$coefficients[,"Pr(>|t|)"][2],3)))     # Add the p-value
a(1)
d.array=array(0,dim=c(3,2,4))       # create 3 by 2 by 4 array full of zeros
d.array
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
unlink("module1_2_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# Contents of working directory
dir()
brain.df <- read.table("http://www.oup.com/us/static/companion.websites/9780195089653/Spreadsheets/brainbody.csv", header=T, sep=",")
head(brain.df)
dim(brain.df)
# ?str: displays the internal structure of the data object
str(data.df)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 2                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
#########################
####  Managing data  ####
#########################
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will probably differ from yours!
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# ?read.csv
# read.table to import textfile (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# ?names: lists names of an object (columns, name of list elements)
names(data.csv.df)
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove redundant objects from memory
rm(data.txt.df)
rm(data.csv.df)
# read built-in data on car road tests performed by Motor Trend
data(mtcars)
str(mtcars)    # examine the structure of this data object
# ?mtcars        # learn more about this built-in data set
####
#### Check/explore data object
####
# ?class: tells you what type of data object you have
class(data.df)
# ?str: displays the internal structure of the data object
str(data.df)
data.df <- read.csv("data.csv")  ## correct our mistake in the previous line (revert to the original data)!
# Right
data.df[,2]==74    # tests each element of column to see whether it is equal to 74
(data.df[,2]<74)|(data.df[,2]==91)
(data.df[,2]<74)||(data.df[,2]==91)
####
####  Practice subsetting a data frame
####
turtles.df <- read.table(file="turtle_data.txt", header=T, stringsAsFactors = FALSE)
names(turtles.df)
head(turtles.df)
# Subset for females
fem.turtles.df <- turtles.df[which(turtles.df$sex =="female"),]
# Can subset just one factor based on another
# Here we want to know the mean weight of all females
mean(fem.turtles.df$weight)
mean(turtles.df$weight[which(turtles.df$sex =="female")])
# Using subset to correct data entry problems
unique(turtles.df$sex)
table(turtles.df$sex)   # do you notice the data entry problem here?
turtles.df[which(turtles.df$sex=="fem"),2]<-"female"            # recode the sex variable
# Try using the "subset()" function, which can make subsetting a data frame even easier!
female.turtles <- subset(turtles.df,sex=="female")              # use the "subset()" function!
female.turtles <- subset(turtles.df,sex!="male")                # alternative
female.turtles <- turtles.df[which(turtles.df$sex!="male"),]    # alternative
subset.turtles.df <- subset(turtles.df, weight >= 10)
head(subset.turtles.df)
# Subsetting to certain individuals
bad.tags <- c(13,105)
good.turtles.df <- turtles.df[!(turtles.df$tag_number %in% bad.tags),]
bad.turtles.df <- turtles.df[turtles.df$tag_number %in% bad.tags,]
bad.turtles.df
# Setting the body length for all turtles with weight 5 or heavier to 48
turtles.df$carapace_length[which(turtles.df$weight >=5)] = 48
turtles.df$size.class
turtles.df$size.class[turtles.df$weight >= 6] <- 1
turtles.df$size.class
turtles.df$size.class[turtles.df$weight < 6] <- 2
turtles.df$size.class
ncol(turtles.df)
# Sets the TRUE indexes from above to 2
turtles.df$size.class <- NA
turtles.df$size.class[turtles.df$weight >= 6] <- 1        # make a new variable "size.class" based on the "weight" variable
turtles.df$size.class[turtles.df$weight < 6] <- 2
turtles.df$size.class
ncol(turtles.df)
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read.table(file="data_missing.txt", sep="\t", header=T)
# Missing data is read as an NA
missing.df
# Missing data is read as an NA
missing.df
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read.table(file="data_missing.txt", sep="\t", header=T)
sink()
missing.df
missing.df
# ?is.na
is.na(missing.df)
# Get index of NAs
which(is.na(missing.df))
# Return only those rows with missing data
missing.df<- read.table(file="data_missing.txt", sep="\t", header=T)
missing.df <- missing.df[!complete.cases(missing.df),]
missing.df
# Can summarize your data and tell you how many NA's per col
summary(missing.mean.df)
# Replace only the missing values of just one column with the mean for that column
missing.mean.df$Export[is.na(missing.mean.df$Export)] <- mean(missing.mean.df$Export,na.rm=T)
####
####  Missing Data
####
# Try reading in a data file with missing values, w/o specifying how the text is delimited
# Will not read because of missing data, it does not know where the columns are!
# missing.df <- read.table(file="data_missing.txt")
# If you specify the header and what the text is delimited by, it will read them as NA
missing.df <- read.table(file="data_missing.txt", sep="\t", header=T)
# Missing data is read as an NA
missing.df
# Omits (removes) rows with missing data
missing.NArm.df <- na.omit(missing.df)
# ?is.na
is.na(missing.df)
# Get index of NAs
which(is.na(missing.df))
# Replace all missing values in the data frame with a 0
missing.df[is.na(missing.df)] <- 0
# Create another data frame with missing values
missing.mean.df<- read.table(file="data_missing.txt", sep="\t", header=T)
# Replace only the missing values of just one column with the mean for that column
missing.mean.df$Export[is.na(missing.mean.df$Export)] <- mean(missing.mean.df$Export,na.rm=T)
missing.mean.df
# Return only those rows with missing data
missing.df<- read.table(file="data_missing.txt", sep="\t", header=T)
missing.df <- missing.df[!complete.cases(missing.df),]
# Can summarize your data and tell you how many NA's per col
summary(missing.mean.df)
# Summarize one individual col
summary(missing.mean.df$Export)
# Summarize one individual col
summary(missing.mean.df$Export)
# Can summarize your data and tell you how many NA's per col
summary(missing.mean.df)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_2.Rmd")
unlink("module1_2_cache", recursive = TRUE)
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_2.Rmd",rmarkdown::pdf_document())
layout(matrix(1:6,nrow=T,byrow=T))
layout.show()
layout.show(1:6)
?layout.show
layout.show(6)
layout.show(5)
layout.show(4)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
plot(x=trees$Girth, y=trees$Volume)             # points
# Use "layout" to define a 2 row x 2 column matrix with elements 1, 2, 3, and 4.
# This divides the image into four sections and then fills these with the plot function
layout(matrix(1:4, nrow=2, ncol=2))
# layout.show(4)   # uncomment to run
# par(mfrow=c(2,2))  # (alternative way to do this)
plot(x=trees$Girth, y=trees$Volume)             # points
plot(x=trees$Girth, y=trees$Volume, type="l")   # lines
plot(x=trees$Girth, y=trees$Volume, type="b")   # both
plot(x=trees$Girth, y=trees$Volume, type="o")   # both with conected lines
# Use layout to define a 2 row x 2 column matrix with elements 1, 1, 2, and 3.
# This divides the image into four sections but fills the first two sections
# with the first plot and then fills these next two sections with the final two plots
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
layout.show(3)
layout.show(1)
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
layout.show(3)
rmarkdown::render("module1_3.Rmd",rmarkdown::pdf_document())
rmd2rscript2("module1_3.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 3                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short-course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
# Thanks to John Tipton at CSU for developing much of this module (plotting in R)!
############################################
####  Data visualization and statistics ####
############################################
# ?trees      # description of built in dataset  (uncomment to run)
dim(trees)   # Show the dimension of the trees dataframe
str(trees)   # Show the structure of the trees dataframe
head(trees)   # Show the first few observations of the trees dataframe
plot(x=trees$Girth, y=trees$Volume)    # use R's built-in "trees" dataset: ?trees
# Use "layout" to define a 2 row x 2 column matrix with elements 1, 2, 3, and 4.
# This divides the image into four sections and then fills these with the plot function
layout(matrix(1:4, nrow=2, ncol=2))
# layout.show(4)   # uncomment to run
# par(mfrow=c(2,2))  # (alternative way to do this)
plot(x=trees$Girth, y=trees$Volume)             # points
plot(x=trees$Girth, y=trees$Volume, type="l")   # lines
plot(x=trees$Girth, y=trees$Volume, type="b")   # both
plot(x=trees$Girth, y=trees$Volume, type="o")   # both with conected lines
# Use layout to define a 3 row x 1 column matrix with elements 1, 2, and 3.
# This divides the image into three sections and then fills these with the plot function
layout(matrix(1:3, nrow=3, ncol=1))
# pch: 'plotting character' changes the type of point that is used (default is an open circle)!
plot(x=trees$Girth, y=trees$Volume, pch=19)     # filled point
plot(x=trees$Girth, y=trees$Volume, pch=2)      # open triangle
plot(x=trees$Girth, y=trees$Volume, pch=11)     # star
layout(matrix(1:4, 2, 2))
# main: adds a title
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees")
# xlab: adds an x axis label
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)")
# ylab: adds a y axis label
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)")
# las: rotates axis labels; las=1 makes them all parallel to reading direction
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1)
# Use layout to define a 2 row x 2 column matrix with elements 1, 1, 2, and 3.
# This divides the image into four sections but fills the first two sections
# with the first plot and then fills these next two sections with the final two plots
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
# col: select a color for the plotting characters
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col="blue")
# We can use the c() function to make a vector and have several colors, plotting characters, etc. per plot.
# We start with alternating colors for each point
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col=c("black", "blue"))
# And we can also alternate the plotting symbol at each point.
plot(x=trees$Girth, y=trees$Volume, pch=c(1,19),
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col="blue")
?iris
head(iris)     # display first few rows of data
dim(iris)      # dimensionality of the data
str(iris)      # details of the data structure
plot.colors <- c("violet", "purple", "blue")   # define the colors for representing species ID
color.vector <- rep(x=plot.colors, each=50)
color.vector
## color vector is now a list of our colors, each repeated 50 times
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Plot of Iris colored by species")
names(plot.colors) <- levels(iris$Species)   # the "levels()" function returns all unique labels for any "factor" variable
plot.colors
indices <- match(iris$Species,names(plot.colors))   # the "match()" function goes through each element of the first vector and finds the matching index in the second vector
indices
# make a new version of the iris data frame that is neither in order nor has the same number of observations for each species (to illustrate generality of the new method)
iris2 <- iris[sample(1:nrow(iris),replace = T),]   # use the "sample()" function to create a randomized ("bootstrapped") version of the iris data frame
# now repeat the above steps:
indices <- match(iris2$Species,names(plot.colors))   # the "match()" function returns the indices of the first vector that match the second vector
color.vector2 <- plot.colors[indices]
plot(x=iris2$Petal.Length, y=iris2$Sepal.Length, pch=19, col=color.vector2,
main="Iris sepal length vs. petal length", xlab="Petal length",
ylab="Sepal length", las=1)
## The old method is NOT general:
color.vector <- rep(x=plot.colors, each=50)
plot(x=iris2$Petal.Length, y=iris2$Sepal.Length, pch=19, col=color.vector,
main="Plot of Iris colored by species (not!)")
## Plot fuel economy by weight
plot(mpg~wt,  data=mtcars,pch=20,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)")      # note the tilde, which can be read "as a function of" -- i.e., "plot mpg as a function of wt"
## Plot fuel economy by weight and horsepower
hp_rescale <- with(mtcars,(hp-min(hp))/diff(range(hp)))    # scale from 0 to 1
plot(mpg~wt,  data=mtcars,pch=1,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)",cex=(hp_rescale+0.6)*1.2)   # plot with different sized points
legend("topright",pch=c(1,1),pt.cex=c(0.6,0.6*1.2),legend=paste(range(mtcars$hp),"horsepower"),bty="n")
## Plot fuel economy by weight and horsepower
hp_rescale <- with(mtcars,(hp-min(hp))/diff(range(hp)))    # scale from 0 to 1
plot(mpg~wt,  data=mtcars,pch=1,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)",cex=(hp_rescale+0.6)*1.2)   # plot with different sized points
legend("topright",pch=c(1,1),pt.cex=c(0.6,0.6*1.2),legend=paste(range(mtcars$hp),"horsepower"),bty="n")
## Plot fuel economy by weight and horsepower again- this time by color
colramp <- terrain.colors(125)
colindex <- round(hp_rescale*99+1)
plot(mpg~wt,  data=mtcars,pch=20,cex=2,xlab="Vehicle weight (1000 lbs)",ylab="Fuel economy (mpg)",col=colramp[colindex])   # plot with different sized points
legend("topright",pch=c(20,20),pt.cex=c(2,2),col=c(colramp[1],colramp[100]),legend=paste(range(mtcars$hp),"horsepower"),bty="n")
by(iris$Sepal.Length, iris$Species, sd)
bar.heights - CI
CI <- 2 * tapply(iris$Sepal.Length, iris$Species, sd)
CI
lwr <- bar.heights - CI
upr <- bar.heights + CI
CI <- 2 * tapply(iris$Sepal.Length, iris$Species, sd)
lwr <- bar.heights - CI
upr <- bar.heights + CI
# I used the ylim= argument to pass a 2-element numeric vector specifying the y extent of the barplot (y axis lower and upper bounds). I added some extra room on the top to account for error bars.
# Importantly, assign the barplot to an object. I called it 'b' but you can call it whatever you like. (otherwise, it's hard to know what the "X" values of the error bars are!)
b <- barplot(bar.heights,
names.arg=c("I. setosa", "I. versicolor", "I. virginica"),
las=1, ylim=c(0,8), col=adjustcolor(plot.colors, alpha.f=0.5),
main="Sepal length for 3 Irises", ylab="Sepal length (cm)")
# Specify where each arrow starts (x0= and y0=) and ends (x1= and y1=)
arrows(x0=b, x1=b, y0=lwr, y1=upr, code=3, angle=90, length=0.1)
# ?arrows
layout(matrix(1:2, 1, 2))
## y-axis is in counts by default (total observations in each "bin")
hist(iris$Sepal.Length, main="Histogram of Sepal Length",
xlab = "Sepal Length")
## change y-axis to proportions of the entire dataset using freq=FALSE
hist(iris$Sepal.Length, freq=FALSE, main="Histogram of Sepal Length",
xlab = "Sepal Length")
## Add a density estimator
lines(density(iris$Sepal.Length))   # add a line to the histogram to approximate the probability density of the data distribution
curve(dnorm(x,mean(iris$Sepal.Length),sd(iris$Sepal.Length)),add=T,col="red",lty=3)   # add a normal distribution
plot.colors <- c("red", "blue")
# subset the colors in plot.colors based on the variable iris$Species
# iris$Species is a factor variable that has 3 levels
color.vector <- plot.colors[ToothGrowth$supp]
plot(x=ToothGrowth$dose, y=ToothGrowth$len, pch=19, col=color.vector,
main="Tooth Growth vs. Vitamin C Dose", xlab="Viatmin C Dose (mg)",
ylab="Tooth Growth (mm)", las=1)
# First legend
legend("topleft", pch=19, col=plot.colors, legend=unique(ToothGrowth$supp))
prop <- c(0.18, 0.25, 0.13, 0.05)
asympLCL <- c(0.14, 0.20, 0.11, 0.035)
asympUCL <- c(0.24, 0.33, 0.18, 0.09)
set.seed(13)
n <- 20 # Number of experimental trials
a <- 12
b <- 1.5
rings <- round(runif(n)*50)  # number of bell rings
wings <- round(a + b*rings + rnorm(n, sd=5))       # number of angels who get their wings
offset <- rpois(n, lambda=10)           # measurement error
lwr <- wings - offset
upr <- wings + offset
rmd2rscript2("module1_3.Rmd")
