sculpin.df <- read.csv("sculpineggs.csv")
head(sculpin.df)
?summarize
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
cache = TRUE
)
sculpin.df %>% summarize(across(everything()) )
sculpin.df %>% summarize(across(everything()),mean )
sculpin.df %>% summarize(across(everything(),mean) )
apply(sculpin.df,2,mean)       # column means of data frame
summary(sculpin.df) # provides a set of summary statistics for all columns in a data frame.
newdf <- read.table(file="data_missing.txt", sep="\t", header=T)  # load dataset with missing data
mean(newdf$Export)
mean(newdf$Export,na.rm = TRUE)
hist(sculpin.df$NUMEGGS)
plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)
hist(sculpin.df$NUMEGGS)
ggplot(sculpin.df,aes(NUMEGGS)) + geom_histogram()
hist(sculpin.df$NUMEGGS)
?geom_histogram
ggplot(sculpin.df,aes(NUMEGGS)) + geom_histogram(bins=5)
ggplot(sculpin.df,aes(FEMWT,NUMEGGS)) + geom_point()
#  Plot data  (base R)
#
# hist(sculpin.df$NUMEGGS)
# plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)
#  Ggplot alternative:
ggplot(sculpin.df,aes(NUMEGGS)) + geom_histogram(bins=5)
ggplot(sculpin.df,aes(FEMWT,NUMEGGS)) + geom_point()
plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)    # plot data
abline(m1)                                           # plot line of best fit
plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)    # plot data
abline(m1)
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)      # fit linear regression model
summary(m1)                             # view model summary
summary(m1)$r.squared                   # extract R-squared
confint(m1)                             # confidence intervals for intercept and slope
AIC(m1)                                 # report AIC (Akaike's Information Criterion, used to perform model selection)
plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)    # plot data
abline(m1)                                           # plot line of best
nd <- data.frame(FEMWT = 30)                   # create new data frame to predict number of eggs at FEMWT of 30
nd <- data.frame(FEMWT = 30)                   # create new data frame to predict number of eggs at FEMWT of 30
predict(m1,newdata=nd)                         # make prediction
predict(m1,newdata=nd,interval="confidence")   # make prediction and get confidence interval
predict(m1,newdata=nd,interval="prediction")   # make prediction and get prediction interval
View(sculpin.df)
mod_logtrans <- lm(log(NUMEGGS) ~ FEMWT, data=sculpin.df)
summary(mod_logtrans)
summary(mod_withI)
mod_withI <- lm(NUMEGGS ~ I(FEMWT^2), data=sculpin.df)                  # fit linear regression model
summary(mod_withI)
# try a model with a polynomial fit
mod_withpoly <- lm(NUMEGGS ~ poly(FEMWT,2),data=sculpin.df)
summary(mod_withpoly)
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ poly(FEMWT,2), data=sculpin.df)           # fit polynomial regression
summary(m3)
#  Model selection example -------------------
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ poly(FEMWT,2), data=sculpin.df)           # fit polynomial regression
summary(m3)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
abline(m3,col="green")
# Use 'predict' to draw lines on scatterplot  -----------------
#  Here's a flexible method for drawing any arbitrary modeled relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred)             # make prediction using "predict()" function
NUMEGGS.pred
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred,interval="confidence")             # make prediction using "predict()" function
NUMEGGS.pred
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
# Use 'predict' to draw lines on scatterplot  -----------------
#  Here's a flexible method for drawing any arbitrary modeled relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred,interval="confidence")             # make prediction using "predict()" function
lines(FEMWT.pred$FEMWT,NUMEGGS.pred,col="green")  # plot sqrt model (note the use of the "lines()" function to draw a line!)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
# Use 'predict' to draw lines on scatterplot  -----------------
#  Here's a flexible method for drawing any arbitrary modeled relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred,interval="confidence")             # make prediction using "predict()" function
lines(FEMWT.pred$FEMWT,NUMEGGS.pred[,1],col="green")  # plot sqrt model (note the use of the "lines()" function to draw a line!)
#Compare models using AIC
AIC(m1)
AIC(m2)
AIC(m3)
#Compare models using R-squared
summary(m1)$r.squared
summary(m2)$r.squared
summary(m3)$r.squared
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="confidence")             # use "predict()" function to compute the confidence interval!
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="confidence")             # use "predict()" function to compute the confidence interval!
lines(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
lines(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
lines(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS))
View(NUMEGGS.confint)
class(NUMEGGS.confint)
# alternative using ggplot:
NUMEGGS.confint2 <- as_tibble(NUMEGGS.confint)
nd
# alternative using ggplot:
NUMEGGS.confint2 <- as_tibble(cbind(nd,NUMEGGS.confint))
View(NUMEGGS.confint2)
?geom_ribbo
?geom_ribbon
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS)) +
geom_line(data=NUMEGGS.confint2,aes(FEMWT,fit)) +
geom_ribbon(data=NUMEGGS.confint2,aes(x=FEMWT,ymin=lwr,ymax=upr),alpha=0.5)
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS)) +
geom_line(data=NUMEGGS.confint2,aes(FEMWT,fit))
NUMEGGS.confint2
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS))
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS)) +
geom_path(data=NUMEGGS.confint2,aes(FEMWT,fit))
# Use 'predict' to draw lines on scatterplot  -----------------
#  Here's a flexible method for drawing any arbitrary modeled relationship!
nd <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=nd,interval="confidence")             # make prediction using "predict()" function
lines(FEMWT.pred$FEMWT,NUMEGGS.pred[,1],col="green")  # plot sqrt model (note the use of the "lines()" function to draw a line!)
#Compare models using AIC
AIC(m1)
AIC(m2)
AIC(m3)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=nd,interval="confidence")             # use "predict()" function to compute the confidence interval!
lines(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
lines(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
lines(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
# alternative using ggplot:
NUMEGGS.confint2 <- as_tibble(cbind(nd,NUMEGGS.confint))
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS)) +
geom_path(data=NUMEGGS.confint2,aes(x=FEMWT,y=fit))
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS)) +
geom_path(data=NUMEGGS.confint2,aes(x=FEMWT,y=fit)) +
geom_ribbon(data=NUMEGGS.confint2,aes(x=FEMWT,ymin=lwr,ymax=upr),alpha=0.5)
m33 <- lm(NUMEGGS ~ poly(FEMWT,3), data=sculpin.df)
nd <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m33,newdata=nd,interval="confidence")             # make prediction using "predict()" function
m33 <- lm(NUMEGGS ~ poly(FEMWT,3), data=sculpin.df)
nd <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.confint <- predict(m33,newdata=nd,interval="confidence")             # make prediction using "predict()" function
NUMEGGS.confint2 <- as_tibble(cbind(nd,NUMEGGS.confint))
ggplot() %>% +
geom_point(data=sculpin.df,mapping=aes(FEMWT,NUMEGGS)) +
geom_path(data=NUMEGGS.confint2,aes(x=FEMWT,y=fit)) +
geom_ribbon(data=NUMEGGS.confint2,aes(x=FEMWT,ymin=lwr,ymax=upr),alpha=0.5)
nd <- data.frame(FEMWT=15)
predict(m33,nd,interval="confidence",alpha=0.95)
nd <- data.frame(FEMWT=5)
predict(m33,nd,interval="confidence",alpha=0.95)
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ poly(FEMWT,2), data=sculpin.df)           # fit polynomial regression
summary(m3)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmarkdown::render("index.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
# load libraries and set working directory
library(dplyr)
library(spData)
library(sf)
library(sf)
library(raster)
library(rgdal)
library(rgeos)
library(rcartocolor)
library(magrittr)
library(leaflet)
## a single point
pt <- st_point(c(1, 1))
plot(pt)
## multiple points
mpt <- st_multipoint(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(0, 0)))
plot(mpt)
## a line
l <- st_linestring(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(0, 0)))
plot(l, col = 'purple')
## a polygon
poly <- st_polygon(list(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(0, 0))))
plot(poly, col = 'purple')
## ...etc, multiline and multipolygons
## a single point
pt <- st_point(c(1, 1))
plot(pt)
pt
# create spatial points data frame ----
## load reptile data
reptiles <- readr::read_csv('reptiles.csv')
?st_as_sf
## inspect the SpatialPoints object
str(sf_points)
# create spatial points data frame ----
## load reptile data
reptiles <- readr::read_csv('reptiles.csv')
## inspect the SpatialPoints object
str(sf_points)
## create a SpatialPoints object
## provide data (x), the columns that contain the x & y (coords)
## and the coordinate reference system (crs)
sf_points <- st_as_sf(x = reptiles,
coords = c('x', 'y'),
crs = '+init=epsg:26911')
sf_points
## create a SpatialPoints object
## provide data (x), the columns that contain the x & y (coords)
## and the coordinate reference system (crs)
sf_points <- st_as_sf(x = reptiles,
coords = c('x', 'y'),
crs = '+init=epsg:26911')
## inspect the SpatialPoints object
str(sf_points)
# create spatial points data frame ----
## load reptile data
reptiles <- readr::read_csv('reptiles.csv')
## create a SpatialPoints object
## provide data (x), the columns that contain the x & y (coords)
## and the coordinate reference system (crs)
sf_points <- st_as_sf(x = reptiles,
coords = c('x', 'y'),
crs = '+init=epsg:26911')
## inspect the SpatialPoints object
str(sf_points)
# inspecting the sf object ----
## checking the projection of the sf object
st_crs(sf_points)
## summary funciton
summary(sf_points)
## what type is the geometry column
class(sf_points$geometry)
## plot the data
plot(sf_points[0])
# subset an sf object ----
phpl <- sf_points[sf_points$species == 'Phrynosoma platyrhinos', ]
head(phpl)
## check to see that there is only one species in the data.frame
phpl %>% magrittr::extract2('species') %>% unique()
class(sf_points)
## we can filter using dplyr syntax
sf_points %>%
dplyr::filter(species == 'Phrynosoma platyrhinos') %>%
head()
## plot with sf::plot
plot(head(sf_points, n = 100))
plot(head(sf_points['year'], n = 100))
## the plot function also uses this syntax to select a single row to plot
## plot(head(sf_points['year'], n = 100))
## and if you don't want to color the plot by feature you can use 0
## to specify plotting 0 attributes
## note, this is plotting all the points
plot(sf_points[0], col = 'purple')
#############
# Nevada Counties example...
# read in nv county shapefile ----
counties <- st_read(dsn = 'data/nv_counties/NV_Admin_Counties.shp')
## once finished check the structure
str(counties, max.level = 3)
## some data management
### check the contents of the geometry field
counties$geometry
### let's double check that projection of the counties
st_crs(counties)
### How does this projection compare to the sf_points object?
### double check the sf_points projection
st_crs(sf_points)
### then explicitly compare them using boolean logic
st_crs(counties) == st_crs(sf_points)
### let's reproject the points to our desired CRS, utm
### we will go into more detail on reprojections later
counties <- st_transform(counties, st_crs(sf_points))
### double check they are equal
st_crs(counties) == st_crs(sf_points)
## check structure of a polygon within a SpatialPolygonsDataFrame
str(counties)
## check the geometry type
class(counties$geometry)
## print the first few rows for inspection
head(counties, n = 4)
## plot a spatial polygon
plot(counties)
## we don't wan't to color by any feature
## st_geometry returns just the geometry column
plot(st_geometry(counties))
## we can plot certain polygons...
## which has a plotting behavior we aren't used to
## this will plot every attribute for the first county
plot(counties[1, ])
## if we only want to include the outline, the following will work
plot(st_geometry(counties)[1])
## multiple at once
layout(matrix(1:3, ncol = 3, nrow = 1))
plot(st_geometry(counties)[1])
plot(st_geometry(counties)[1:4])
plot(st_geometry(counties)[counties$CNTYNAME == 'Clark'])
## we can even plot our reptile points ontop of the counties
layout(matrix(1))
plot(st_geometry(counties))
plot(st_geometry(sf_points), pch = 1, cex = .5, col = 'purple', add = TRUE)
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_5.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
cache = TRUE
)
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module2_1.Rmd")
?Reduce
